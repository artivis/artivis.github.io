<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Raspberry Pi | Home to artivis</title><link>https://artivis.github.io/tag/raspberry-pi/</link><atom:link href="https://artivis.github.io/tag/raspberry-pi/index.xml" rel="self" type="application/rss+xml"/><description>Raspberry Pi</description><generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><lastBuildDate>Wed, 19 May 2021 00:00:00 +0000</lastBuildDate><image><url>https://artivis.github.io/media/icon_hud2d1771ce140e1d1fd4d0e59d51cebc4_11712_512x512_fill_lanczos_center_3.png</url><title>Raspberry Pi</title><link>https://artivis.github.io/tag/raspberry-pi/</link></image><item><title>Getting started with micro-ROS on the Pi Pico</title><link>https://artivis.github.io/post/2021/pi-pico-uros-getting-started/</link><pubDate>Wed, 19 May 2021 00:00:00 +0000</pubDate><guid>https://artivis.github.io/post/2021/pi-pico-uros-getting-started/</guid><description>&lt;p>In this post we will see how the Pi Pico can natively speak to a ROS2 graph using micro-ROS.
We will set up a project in VSCode, compile and upload it to the microcontroller.
We thus assume that you are somewhat familiar with &lt;a href="https://docs.ros.org/en/foxy/index.html" target="_blank" rel="noopener">ROS2 development&lt;/a> and &lt;a href="https://code.visualstudio.com" target="_blank" rel="noopener">VSCode&lt;/a>.&lt;/p>
&lt;hr>
&lt;h2 id="content">Content&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="#content">Content&lt;/a>&lt;/li>
&lt;li>&lt;a href="#what-is-this-all-about">What is this all about?&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#the-raspberry-pi-pico">The Raspberry Pi Pico&lt;/a>&lt;/li>
&lt;li>&lt;a href="#micro-ros">micro-ROS&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#getting-started">Getting started&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#installing-dependencies">Installing dependencies&lt;/a>&lt;/li>
&lt;li>&lt;a href="#fetching-the-sources">Fetching the sources&lt;/a>&lt;/li>
&lt;li>&lt;a href="#setting-up-vscode">Setting up VSCode&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#running-the-example">Running the example&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#wait-a-minute-what-does-it-do">Wait a minute. What does it do?&lt;/a>&lt;/li>
&lt;li>&lt;a href="#uploading-to-the-pi-pico">Uploading to the Pi Pico&lt;/a>&lt;/li>
&lt;li>&lt;a href="#installing-the-micro-ros-agent">Installing the micro-ros-agent&lt;/a>&lt;/li>
&lt;li>&lt;a href="#actually-running-the-example">Actually running the example&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#whats-next">What&amp;rsquo;s next?&lt;/a>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="what-is-this-all-about">What is this all about?&lt;/h2>
&lt;h3 id="the-raspberry-pi-pico">The Raspberry Pi Pico&lt;/h3>
&lt;p>The Raspberry Pi Pico, &lt;a href="https://www.raspberrypi.org/blog/raspberry-pi-silicon-pico-now-on-sale/" target="_blank" rel="noopener">announced in late January 2021&lt;/a>,
is the newest release of the Raspberry Pi Foundation which received a ton of attention (a quick search on Google and/or Youtube will convince you).
And that&amp;rsquo;s for a good reason.
Compared to its well known predecessors,
this new board differs in two major ways:
it is an &lt;em>in-house&lt;/em> designed open-hardware &lt;em>microcontroller&lt;/em>!
Yes, the chip itself is designed by the Pi&amp;rsquo;s engineers and it is fully open-hardware.
And as usually with the Pi foundation,
it is incredibly affordable at just 4$.&lt;/p>
&lt;p>The details concerning the board itself,
the differences between microprocessor and microcontroller,
the 101 getting started or what can the Pi Pico do;
all of that is beyond the scope of this post.
But I strongly encourage you having a look for yourself,
whether you are familiar with microcontrollers or not.&lt;/p>
&lt;h3 id="micro-ros">micro-ROS&lt;/h3>
&lt;p>In the ROS (1) realm, microcontrollers have always been sort of second class citizens.
They can&amp;rsquo;t interact directly with the ROS graph and developers have to rely on libraries such as &lt;a href="http://wiki.ros.org/rosserial" target="_blank" rel="noopener">rosserial&lt;/a>.
But ROS2 is a whole new world and things are changing.&lt;/p>
&lt;blockquote>
&lt;p>micro-ROS puts ROS 2 onto microcontrollers, making them first class participants of the ROS 2 environment.&lt;/p>
&lt;/blockquote>
&lt;p>The &lt;a href="https://micro-ros.github.io/" target="_blank" rel="noopener">micro-ROS&lt;/a> project is an effort led by &lt;a href="https://micro.ros.org/docs/overview/users_and_clients/" target="_blank" rel="noopener">big industrial names&lt;/a> such as Bosch,
eProsima, Fiware Foundation, notably through the &lt;a href="http://www.ofera.eu/" target="_blank" rel="noopener">OFERA&lt;/a> H2020 project,
and a myriad of partners and collaborators including e.g. Amazon and Canonical.&lt;/p>
&lt;p>So what is it? It is essentially a thin wrapper (see its &lt;a href="https://micro-ros.github.io/docs/concepts/client_library/decision_paper/" target="_blank" rel="noopener">design document&lt;/a>) on top of &amp;lsquo;DDS for eXtremely Resource Constrained Environments&amp;rsquo; (&lt;a href="https://www.omg.org/spec/DDS-XRCE/" target="_blank" rel="noopener">DDS-XRCE&lt;/a>),
running on a real-time OS, allowing microcontrollers to &amp;lsquo;speak&amp;rsquo; to a ROS2 graph (the usual talker/listener) using an optimized subset of the DDS protocol.
It relies on a &amp;lsquo;bridged&amp;rsquo; communication architecture with a &amp;lsquo;broker&amp;rsquo; named the &lt;a href="https://github.com/micro-ROS/micro-ROS-Agent" target="_blank" rel="noopener">&amp;lsquo;micro-ros-agent&amp;rsquo;&lt;/a>.
The agent is in charge of the interfacing between the ROS2 graph and one or several micro-ROS devices.&lt;/p>
&lt;p>More details can be found on the &lt;a href="https://micro-ros.github.io/" target="_blank" rel="noopener">micro-ROS website&lt;/a> including how it compares/differs from rosserial (see &lt;a href="https://micro-ros.github.io/docs/overview/comparison/" target="_blank" rel="noopener">here&lt;/a> and &lt;a href="https://micro.ros.org/docs/concepts/middleware/rosserial/" target="_blank" rel="noopener">here&lt;/a>).&lt;/p>
&lt;h2 id="getting-started">Getting started&lt;/h2>
&lt;p>Alright, so now that we have clarified a couple terms,
let us get started, step by step,
with micro-ROS on Pi Pico with the &lt;a href="https://github.com/micro-ROS/micro_ros_raspberrypi_pico_sdk" target="_blank" rel="noopener">official example available on github&lt;/a>.
Note that for this tutorial I am running Ubuntu 20.04 with the &lt;a href="https://snapcraft.io/code" target="_blank" rel="noopener">VSCode snap&lt;/a>.&lt;/p>
&lt;p>If you are not running Ubuntu 20.04 yet, you could consider using a LXD container.
You can refer to my previous post &lt;a href="https://artivis.github.io/post/2020/lxc/" target="_blank" rel="noopener">&amp;lsquo;ROS Noetic development workflow in LXC&amp;rsquo;&lt;/a> to help you get started setting up the container.&lt;/p>
&lt;h3 id="installing-dependencies">Installing dependencies&lt;/h3>
&lt;p>Let&amp;rsquo;s start simple by installing the couple necessary dependencies,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sudo apt install build-essential cmake gcc-arm-none-eabi libnewlib-arm-none-eabi doxygen git python3
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="fetching-the-sources">Fetching the sources&lt;/h3>
&lt;p>We will now create a workspace and fetch all the sources,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">mkdir -p ~/micro_ros_ws/src
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">cd&lt;/span> ~/micro_ros_ws/src
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git clone --recurse-submodules https://github.com/raspberrypi/pico-sdk.git
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git clone https://github.com/micro-ROS/micro_ros_raspberrypi_pico_sdk.git
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The first repository is the Pi Pico SDK provided by the Pi foundation.
The second contains a precompiled micro-ROS stack together with a hello-world-like example.&lt;/p>
&lt;h3 id="setting-up-vscode">Setting up VSCode&lt;/h3>
&lt;p>Let us now open the example in VSCode and set it up.
To follow along, you will need two VSCode extensions that are rather common for C++ development.
These extensions are the &lt;a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools" target="_blank" rel="noopener">C++ extension&lt;/a> and &lt;a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cmake-tools" target="_blank" rel="noopener">CMake tools&lt;/a> for VSCode.
After installing them, we will create a configuration file for CMake tools and set a variable so that our project knows where to find the Pi Pico SDK.
To do so, simply type,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="nb">cd&lt;/span> ~/micro_ros_ws/src/micro_ros_raspberrypi_pico_sdk
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mkdir .vscode
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">touch .vscode/settings.json
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Open the newly created file with your favorite editor,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">vi .vscode/settings.json
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>and add the following,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;cmake.configureEnvironment&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;PICO_SDK_PATH&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;/home/artivis/micro_ros_ws/src/pico-sdk&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This variable is an environment variable that is only passed to CMake at configuration time.
See the &lt;a href="https://vector-of-bool.github.io/docs/vscode-cmake-tools/settings.html?highlight=configureenvironment" target="_blank" rel="noopener">CMake-Tools documentation&lt;/a> for more info.&lt;/p>
&lt;p>Let us now open it,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">code .
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Before running the CMake configuration and build it,
we must select the appropriate &amp;lsquo;kit&amp;rsquo; (maybe VSCode has already asked you to do so).
Open the palette (ctrl+shift+p) and search for &lt;code>'CMake: Scan for Kits'&lt;/code> and then &lt;code>'CMake: Select a Kit'&lt;/code> and make sure to select the compiler we&amp;rsquo;ve installed above, that is &lt;code>'GCC for arm-non-eabi'&lt;/code>.&lt;/p>
&lt;p>We&amp;rsquo;re all set, let us build the example!
Open the palette again and hit &lt;code>'CMake: Build'&lt;/code>.&lt;/p>
&lt;h2 id="running-the-example">Running the example&lt;/h2>
&lt;h3 id="wait-a-minute-what-does-it-do">Wait a minute. What does it do?&lt;/h3>
&lt;p>Right, let&amp;rsquo;s break down very briefly what the example does.
It sets up a node called &lt;code>'pico_node'&lt;/code>,
then a publisher publishing a &lt;code>'std_msgs/msg/int32.h'&lt;/code> message on topic &lt;code>'pico_publisher'&lt;/code>,
a recurring timer and an executor to orchestrate everything.
Every 0.1 second, the executor spins.
But only every second, the timer will have the publisher publish a message and increase the message data by 1.
Simple. So let&amp;rsquo;s try it out.&lt;/p>
&lt;h3 id="uploading-to-the-pi-pico">Uploading to the Pi Pico&lt;/h3>
&lt;p>If everything went fine during compilation,
you should see a new &lt;code>'build'&lt;/code> folder in your project view.
In this folder, you will find the file that we should now upload to the Pi Pico,
it is named here &lt;code>'pico_micro_ros_example.uf2'&lt;/code>.
To upload it, simply connect the board with a USB cable &lt;strong>while pressing&lt;/strong> the tiny white button labelled &lt;code>'BOOTSEL'&lt;/code>.
Doing so, the Pi Pico will mount similarly to a flash drive allowing us to very easily copy/paste the &amp;lsquo;&lt;code>.uf2&lt;/code>&amp;rsquo; file.&lt;/p>
&lt;p>Head to a terminal and type,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="nb">cd&lt;/span> build
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cp pico_micro_ros_example.uf2 /media/&lt;span class="nv">$USER&lt;/span>/RPI-RP2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Once the file is copied,
the board will automatically reboot and start executing the example.&lt;/p>
&lt;p>Easy-peasy.&lt;/p>
&lt;h3 id="installing-the-micro-ros-agent">Installing the micro-ros-agent&lt;/h3>
&lt;p>We have seen in the introduction that micro-ROS has a bridged communication architecture.
We thus have to build that bridge.
Well, fortunately the development team has built it already and distributes it both as a &lt;a href="https://snapcraft.io/micro-ros-agent" target="_blank" rel="noopener">Snap&lt;/a> or a &lt;a href="https://hub.docker.com/r/microros/micro-ros-agent" target="_blank" rel="noopener">Docker image&lt;/a>.
Here we&amp;rsquo;ll make use of the former.
If you are using Ubuntu 16.04 or later, snap is already pre-installed and ready to go.
If you are running another OS, you can either &lt;a href="https://snapcraft.io/docs/installing-snap-on-ubuntu" target="_blank" rel="noopener">install snap&lt;/a> or make use of the Docker image.&lt;/p>
&lt;p>To install the micro-ros-agent snap, type,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sudo snap install micro-ros-agent
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>After installing it, and because we are using a serial connection,
we need to configure a couple things.
First we need to enable the &lt;code>'hotplug'&lt;/code> feature,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sudo snap &lt;span class="nb">set&lt;/span> core experimental.hotplug&lt;span class="o">=&lt;/span>&lt;span class="nb">true&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>and restart the snap demon so that it takes effect,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sudo systemctl restart snapd
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>After making sure the Pi Pico is plugged, execute,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ snap interface serial-port
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">name: serial-port
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">summary: allows accessing a specific serial port
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">plugs:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> - micro-ros-agent
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">slots:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> - snapd:pico &lt;span class="o">(&lt;/span>allows accessing a specific serial port&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>What we see here is that the micro-ros-agent snap has a serial &amp;lsquo;&lt;code>plug&lt;/code>&amp;rsquo; while a &amp;lsquo;&lt;code>pico&lt;/code>&amp;rsquo; &lt;code>'slot'&lt;/code> magically appeared.
As per the semantic, we probably should connect them together. To do so run,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">snap connect micro-ros-agent:serial-port snapd:pico
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We are now all set to finally run our example.&lt;/p>
&lt;h3 id="actually-running-the-example">Actually running the example&lt;/h3>
&lt;p>With the Pi Pico plugged through USB,
we will start the micro-ros-agent as follows,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">micro-ros-agent serial --dev /dev/ttyACM0 &lt;span class="nv">baudrate&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">115200&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>and wait a couple seconds for the Pi Pico&amp;rsquo;s LED to light up indicating that the main loop is running.
In case it does not light up after a few long seconds (count up to 10 mississippi),
you may want to unplug/replug the board in order to reboot it.
The initialization procedure of the example lacks a few error checking.
Hey, could fixing that be &lt;strong>your&lt;/strong> first project?&lt;/p>
&lt;p>So now the LED should shine a bright green.
That&amp;rsquo;s cool.
Do you know what&amp;rsquo;s cooler?
Running on your host machine,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ &lt;span class="nb">source&lt;/span> /opt/ros/dashing/setup.bash
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ ros2 topic &lt;span class="nb">echo&lt;/span> /pico_publisher
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">data: &lt;span class="m">41&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">---
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">data: &lt;span class="m">42&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">---
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Awesome!&lt;/p>
&lt;p>And hitting a&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ ros2 node list
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">/pico_node
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>proves that the micro-ROS node running on the Pi Pico is visible to ROS2 on the host machine.&lt;/p>
&lt;p>Yatta!&lt;/p>
&lt;h2 id="whats-next">What&amp;rsquo;s next?&lt;/h2>
&lt;p>For a long time it wasn&amp;rsquo;t convenient to mix microcontrollers and ROS.
But this is about to seriously change as we&amp;rsquo;ve just seen.
No doubt that both micro-ROS and the Pi Pico will bolster great robotics applications (and more!).&lt;/p>
&lt;p>In this tutorial we&amp;rsquo;ve reached a great starting point with a ROS2-based project ready to spin on the suppa-cool suppa-affordable Pi Pico.&lt;/p>
&lt;p>Of course this wouldn&amp;rsquo;t have been possible without the micro-ROS dev team and Cyberbotics engineer Darko LukiÄ‡ (&lt;a href="https://github.com/lukicdarkoo" target="_blank" rel="noopener">@lukicdarkoo&lt;/a>) who has put together the initial example we&amp;rsquo;ve just used.
As often, there are super smart people out there making complicated stuff very accessible,
shout out to them.&lt;/p>
&lt;p>I&amp;rsquo;m personally going to keep playing with micro-ROS on Pi Pico,
first because it is fun and second because I have a couple ideas up my sleeves.
Be sure that if they become reality you&amp;rsquo;ll hear about them on this blog.&lt;/p>
&lt;p>What about you? Do you have some cool projects already in mind?&lt;/p>
&lt;!-- uROS main links --></description></item><item><title>Publishing sonar readings with micro-ROS on the Raspberry Pi Pico</title><link>https://artivis.github.io/post/2021/pi-pico-uros-sonar/</link><pubDate>Fri, 12 Mar 2021 00:00:00 +0000</pubDate><guid>https://artivis.github.io/post/2021/pi-pico-uros-sonar/</guid><description>&lt;p>In this post we will see how to wire up an HC-SR04 range sensor to the Raspberry Pi Pico and publish its readings to the ROS 2 graph using micro-ROS.
This builds upon the previous post &lt;a href="pi-pico-uros-getting-started.md">&amp;lsquo;Getting started with micro-ROS on the Pi Pico&amp;rsquo;&lt;/a>,
as such I&amp;rsquo;d encourage you to read it first if you are not already familiar with the topic.&lt;/p>
&lt;hr>
&lt;h2 id="content">Content&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="#content">Content&lt;/a>&lt;/li>
&lt;li>&lt;a href="#a-sensor-you-said">A sensor you said?&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#im-batsensor">&amp;ldquo;I&amp;rsquo;m Bat(sensor)&amp;rdquo;&lt;/a>&lt;/li>
&lt;li>&lt;a href="#which-sonar-model-to-pick">Which sonar model to pick?&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#wiring-up-the-sonar-to-the-pi-pico">Wiring up the sonar to the Pi Pico&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#micro-code-for-micro-ros">Micro code for micro-ROS&lt;/a>&lt;/li>
&lt;li>&lt;a href="#bip-bip-bip">Bip bip bip&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#whats-next">What&amp;rsquo;s next?&lt;/a>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="a-sensor-you-said">A sensor you said?&lt;/h2>
&lt;p>In this tutorial, we will make use of one of the most common sensors in robotics, a sonar.
These sensors are cheap, fairly simple to use and surprisingly precise under favorable circumstances.
Sonars are used to measure distances and can therefore be used to detect and locate obstacles so that one can make sure its robot does not run into nearby things.
It is no mystery why they are so incredibly popular.&lt;/p>
&lt;p>So, what&amp;rsquo;s a sonar, how does it work, which one should I pick?&lt;/p>
&lt;h3 id="im-batsensor">&amp;ldquo;I&amp;rsquo;m Bat(sensor)&amp;rdquo;&lt;/h3>
&lt;p>A sonar is an echolocation sensor which allows for measuring distances.
To keep things simple to digest,
sonars work the same way as bats do.
Nah they don&amp;rsquo;t fly, hunting bugs at dawn;
nor do they fight crime.
I obviously meant the same way as bats perceive the world.
A sonar is composed of an emitter and a receiver.
The former emits an ultrasound signal,
which will bounce off of facing obstacles,
back at the receiver.
Measuring the time difference between the signal emission and reception,
one can easily calculate the distance travelled by the sound wave and thus the distance to the obstacle that reverberated the sound.&lt;/p>
&lt;p>This technology can suffer from all kind of issues if, for example,
the sound wave is reverberated away from the sensor,
or if it is reverberated back to the sensor by two obstacles at different distances,
or if it is absorbed by some sound dampening material.&lt;/p>
&lt;p>If this is still unclear or you want to know more about it,
I&amp;rsquo;ll redirect you to your favorite web search engine as it is a little out of the scope of this post.&lt;/p>
&lt;h3 id="which-sonar-model-to-pick">Which sonar model to pick?&lt;/h3>
&lt;p>There exists plenty different models of sonars,
fortunately most of them works the same way.
Furthermore they can be found for a few bucks per unit on the internet.
Head on over to your favorite electronics supplier and you&amp;rsquo;re sure to find them for sale.&lt;/p>
&lt;p>I&amp;rsquo;d recommend you use the &amp;lsquo;HC-SR04P&amp;rsquo; model which is the 3.3V variant of the immensely popular &amp;lsquo;HC-SR04&amp;rsquo; (5V).
It is this model (the &amp;lsquo;HC-SR04P&amp;rsquo;) I will be using in this post.
Given its very small power consumption, it can be powered up directly from the Pi Pico and thus the whole setup can simply be powered from the USB cable.
In case you are using a 5V package, make sure to adapt the wiring described below or else you are risking damages to your Pi Pico!
For reference, I ordered a lot of 5 units for less than 10$ including shipping.
Including the Pi Pico price,
that&amp;rsquo;s a lot of sensing for the price!&lt;/p>
&lt;h2 id="wiring-up-the-sonar-to-the-pi-pico">Wiring up the sonar to the Pi Pico&lt;/h2>
&lt;p>The &amp;lsquo;HC-SR04P&amp;rsquo; board comes with four pins labelled
&amp;lsquo;Vcc&amp;rsquo;, &amp;lsquo;Gnd&amp;rsquo;, &amp;lsquo;Trig&amp;rsquo; and &amp;lsquo;Echo&amp;rsquo;.
As you&amp;rsquo;ve already guessed, the Vcc and Gnd pins are for the 3.3V line and the ground respectively,
while &amp;lsquo;Trig&amp;rsquo; is used to trigger the sensor and &amp;lsquo;Echo&amp;rsquo; reports the reception of the echo (the reception of the sound wave that bounced off of an obstacle).&lt;/p>
&lt;p>From there, and referring to the &lt;a href="https://datasheets.raspberrypi.org/pico/Pico-R3-A4-Pinout.pdf" target="_blank" rel="noopener">Pi Pico pinout&lt;/a>,
the wiring is straight forward:&lt;/p>
&lt;ul>
&lt;li>connect Pico&amp;rsquo;s pin 36 (3V3 OUT) to the sonar&amp;rsquo;s &amp;lsquo;Vcc&amp;rsquo;&lt;/li>
&lt;li>connect Pico&amp;rsquo;s pin 38 (GND) to the sonar&amp;rsquo;s &amp;lsquo;Gnd&amp;rsquo;&lt;/li>
&lt;li>connect Pico&amp;rsquo;s pin 9 (GPIO 6) to the sonar&amp;rsquo;s &amp;lsquo;Echo&amp;rsquo;&lt;/li>
&lt;li>connect Pico&amp;rsquo;s pin 10 (GPIO 7) to the sonar&amp;rsquo;s &amp;lsquo;Trig&amp;rsquo;&lt;/li>
&lt;/ul>
&lt;p>This setup is depicted in the figure below.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://artivis.github.io/img/post/2021/uros_pico_sonar.png" alt="Wiring the HC-SR04P to the Pico" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>As far as the hardware goes, we&amp;rsquo;re done.
Let us move to the software.&lt;/p>
&lt;h3 id="micro-code-for-micro-ros">Micro code for micro-ROS&lt;/h3>
&lt;p>We&amp;rsquo;ve seen in the &lt;a href="pi-pico-uros-getting-started.md">&amp;lsquo;previous post&amp;rsquo;&lt;/a> how to set up VSCode for programming micro-ros, and how to compile and flash a program on the Pi Pico.
We&amp;rsquo;ll thus refer to the aforementioned post on how to do all that and skip it here.
Similarly, we&amp;rsquo;ll skip all the boilerplate code and only show the bits specific to our application.
However, know that this example (and more) is fully available on github at &lt;a href="https://github.com/artivis/mico_ros" target="_blank" rel="noopener">artivis/mico_ros&lt;/a>.&lt;/p>
&lt;p>Alright, let&amp;rsquo;s dive a little.
Our application is essentially composed of two functions,
one that triggers and reads the sensor,
and a second, the timer callback, which calls the first,
fill up a ROS message and publishes it:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// The GPIO pins to which the sonar is wired
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="cp">#define GPIO_ECHO 6
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#define GPIO_TRIGGER 7
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * @brief Get the range value in meter.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">float&lt;/span> &lt;span class="n">read_range&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Send an impulse trigger of 10us
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">gpio_put&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">GPIO_TRIGGER&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sleep_us&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">gpio_put&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">GPIO_TRIGGER&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Read how long is the echo
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">uint32_t&lt;/span> &lt;span class="n">signaloff&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">signalon&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">do&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">signaloff&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">time_us_32&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">gpio_get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">GPIO_ECHO&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">do&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">signalon&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">time_us_32&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">gpio_get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">GPIO_ECHO&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Actual echo duration in us
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="kt">float&lt;/span> &lt;span class="n">dt&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">signalon&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">signaloff&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// distance in meter:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// echo duration (us) x speed of sound (m/us) / 2 (round trip)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">dt&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mf">0.000343&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="mf">2.0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * @brief Read the range from the sensor,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * fill up the ROS message and publish it.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="n">timer_callback&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">rcl_timer_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">timer&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int64_t&lt;/span> &lt;span class="cm">/*last_call_time*/&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">timer&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">range_msg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">range&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">read_range&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">fill_msg_stamp&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">range_msg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">header&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">stamp&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">rcl_publish&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">publisher&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">range_msg&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Failed to publish range. Continuing.&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>That&amp;rsquo;s pretty much it.
The rest of the code is mostly boilerplate,
initializing the GPIO,
setting up the micro-ROS node, publisher, timer and executor,
and having it all spin.&lt;/p>
&lt;p>Note that we are using the standard &lt;code>sensor_msgs/msgs/Range&lt;/code> message.
You can find its definition and a breakdown of its field online in the &lt;a href="https://docs.ros2.org/latest/api/sensor_msgs/msg/Range.html" target="_blank" rel="noopener">ROS2 API documentation&lt;/a>.&lt;/p>
&lt;p>All there is to do now is to compile the code,
flash the resulting &amp;lsquo;.uf2&amp;rsquo; file and start the micro-ROS agent.&lt;/p>
&lt;h3 id="bip-bip-bip">Bip bip bip&lt;/h3>
&lt;p>Assuming compiling and flashing went all fine,
all we have to do is to plug the board to our computer and launch the micro-ROS agent.
We do so with the following command:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">docker run -it --rm -v /dev:/dev --privileged --net&lt;span class="o">=&lt;/span>host microros/micro-ros-agent:foxy serial --dev /dev/ttyACM0 -b &lt;span class="m">115200&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Let&amp;rsquo;s see if we get anything,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ ros2 topic list
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">/parameter_events
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">/pico/range
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">/rosout
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>the topic &lt;code>/pico/range&lt;/code> is advertised, that&amp;rsquo;s a good start.
Let see what it contains,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ ros2 topic &lt;span class="nb">echo&lt;/span> /pico/range
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">header:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> stamp:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> sec: &lt;span class="m">145&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> nanosec: &lt;span class="m">837599000&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> frame_id: pico_sonar_0_link
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">radiation_type: &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">field_of_view: 30.0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">min_range: 0.019999999552965164
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">max_range: 4.0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">range: 12.138598442077637
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">---
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">header:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> stamp:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> sec: &lt;span class="m">145&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> nanosec: &lt;span class="m">915356000&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> frame_id: pico_sonar_0_link
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">radiation_type: &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">field_of_view: 30.0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">min_range: 0.019999999552965164
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">max_range: 4.0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">range: 12.138941764831543
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">---
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>That looks great!&lt;/p>
&lt;p>You could now play with your new sensor,
moving an obstacle back and forth in front of it.
Take a measuring tape and compare the reported distance to the measured one,
you may be surprised by its accuracy, I know I was.&lt;/p>
&lt;h2 id="whats-next">What&amp;rsquo;s next?&lt;/h2>
&lt;p>This is a neat little project to approach micro-ROS and the possibilities it opens.
Indeed it is really rewarding to see the actual distance between the sensor and an obstacle being readily available on our ROS 2 graph.
But taking a step back we can start seeing an slightly larger picture;
a picture in which one will be able to easily, effortlessly,
add plug&amp;rsquo;n&amp;rsquo;play ROS2-ready hardware modules to existing robots.
Plug a camera and its feed magically appears on the graph,
an IMU module could provide a reliable odometry source,
a motor ready to spin in a snap (pun intended).&lt;/p>
&lt;p>We&amp;rsquo;re not there yet, but I&amp;rsquo;m definitely going to follow this line of thought for my own Turtlebot 3.
Can you believe that it doesn&amp;rsquo;t have any sonar?!&lt;/p>
&lt;p>Fortunately now I can easily add a pair of them and have my robot stop bumping into my lazy cat lying down on the floor,
unwitting ninja, invisible to the laser scanner ðŸ˜….&lt;/p></description></item><item><title>Downloading Raspberry Pi Press issues</title><link>https://artivis.github.io/post/2020/rpipress/</link><pubDate>Thu, 09 Jul 2020 00:00:00 +0000</pubDate><guid>https://artivis.github.io/post/2020/rpipress/</guid><description>&lt;p>In this post we will discover the great magazines edited under the
Raspberry Pi Press umbrella and discuss how to easily access them all.&lt;/p>
&lt;hr>
&lt;h2 id="content">Content&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="#content">Content&lt;/a>&lt;/li>
&lt;li>&lt;a href="#the-raspberry-pi-press-magazines">The Raspberry Pi Press magazines&lt;/a>&lt;/li>
&lt;li>&lt;a href="#bookshelf">Bookshelf&lt;/a>&lt;/li>
&lt;li>&lt;a href="#rpipress-downloader">rpipress-downloader&lt;/a>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="the-raspberry-pi-press-magazines">The Raspberry Pi Press magazines&lt;/h2>
&lt;p>The &lt;a href="https://store.rpipress.cc/" target="_blank" rel="noopener">Raspberry Pi Press&lt;/a> is a part of the Raspberry Pi Foundation
and the publisher of a great deal of magazines and books.
Among the many magazines edited, some are freely available for download,&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://hackspace.raspberrypi.org/" target="_blank" rel="noopener">HackSpace&lt;/a> is a monthly publication dedicated to those who love to make things
and learn while doing it.&lt;/li>
&lt;li>&lt;a href="https://helloworld.raspberrypi.org/" target="_blank" rel="noopener">HelloWorld&lt;/a> is published three times a year and targets educators
of the computing and digital world.&lt;/li>
&lt;li>&lt;a href="https://magpi.raspberrypi.org/" target="_blank" rel="noopener">MagPi&lt;/a> is the official magazine of the Raspberry Pi and is loaded
with stories and project based on the single board computer.
Published every month, the latest issue is numbered NÂ°95 as of the time of writing,
making it an incredible source of inspiration.&lt;/li>
&lt;li>&lt;a href="https://wireframe.raspberrypi.org/" target="_blank" rel="noopener">Wiredframe&lt;/a> is published every 2 weeks and is entirely dedicated
to video games. But unlike other video game magazines, it offers
to look at how they are made, who make them and offer a lot of resources
to get started writing your own games.&lt;/li>
&lt;/ul>
&lt;p>On top of that, The Raspberry Pi Press also publishes many great books.&lt;/p>
&lt;p>Each magazine can be bought online and shipped around the globe.
One can also sign for a yearly subscription, offering some
discount and/or goodies. At the same time, issues are freely available
to download in pdf from the magazine websites.&lt;/p>
&lt;h2 id="bookshelf">Bookshelf&lt;/h2>
&lt;p>Recently the &lt;a href="https://www.raspberrypi.org/blog/latest-raspberry-pi-os-update-may-2020/" target="_blank" rel="noopener">Raspberry Pi Foundation presented the Raspberry Pi OS&lt;/a>,
a rebranding of Raspbian, highlighting some of its novelties.
Among those novelties, they showcased a neat little app named &lt;code>Bookshelf&lt;/code>
that allows you to browse and download the issues of
several magazines edited by the Raspberry Pi Press.&lt;/p>
&lt;p>The application is a simple interface listing all issues of each magazine
but also some of the books.
It allows for simply downloading any issue by simply clicking on
the desired cover.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://artivis.github.io/img/post/bookshelf.png" alt="The Bookshelf app" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>Unfortunately this great app is only available through the Pi OS
archive and its &lt;a href="https://www.raspberrypi.org/forums/viewtopic.php?f=63&amp;amp;t=278584&amp;amp;p=1687369&amp;amp;hilit=bookshelf#p1687369" target="_blank" rel="noopener">source code is not public&lt;/a> at the time of writing.
One can still download the deb package and install it manually.
To do so, visit the &lt;a href="http://archive.raspberrypi.org/debian/pool/main/r/rp-bookshelf/" target="_blank" rel="noopener">app archive&lt;/a> and look for the latest
version of the debian package for your machine architecture.
At the moment it is &lt;code>rp-bookshelf_0.4_amd64.deb&lt;/code> for common computers.
From there, we can simply download the debian and install it,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">wget http://archive.raspberrypi.org/debian/pool/main/r/rp-bookshelf/rp-bookshelf_0.4_amd64.deb
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">dpkg -i rp-bookshelf_0.4_amd64.deb
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>To launch the app simply type,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">rp-bookshelf
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Altho this procedure works fine, it is a little unpleasant.
Furthermore, I personally don&amp;rsquo;t care much about the GUI and I&amp;rsquo;d rather prefer
to automatically download the latest issues I care for.
If you feel the same, keep on reading.&lt;/p>
&lt;h2 id="rpipress-downloader">rpipress-downloader&lt;/h2>
&lt;p>The Raspberry Pi Press Store was &lt;a href="https://www.raspberrypi.org/blog/the-raspberry-pi-press-store-is-looking-mighty-fine/" target="_blank" rel="noopener">recently entirely redesigned&lt;/a>
bringing some uniformization across all the magazine websites.
That allows us to write a small web scrapping script to automatically
download the latest (or all) issues and books of our favorite magazine(s).&lt;/p>
&lt;p>So I went ahead and did just that, writing a small Python script that you can find
on &lt;a href="https://github.com/artivis/rpipress-downloader" target="_blank" rel="noopener">Github&lt;/a>, or conveniently install as a Snap as follows,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sudo snap install rpipress-downloader
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Its use it pretty simple, launch the script in a terminal
and by default it will automatically search and download the latest issue of all
aforementioned magazines.&lt;/p>
&lt;p>Further options let you:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>specify which magazine to download&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">rpipress-downloader --magazines magpi hackspace
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>download &lt;strong>all&lt;/strong> issues,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">rpipress-downloader --all
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>download the books too,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">rpipress-downloader --books
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>combine options so that,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">rpipress-downloader -a -m magpi -b
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>will download all MagPi issues and books.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Issues and books are saved respectively in&lt;/p>
&lt;ul>
&lt;li>&lt;code>~/rpipress/{magazine}&lt;/code>&lt;/li>
&lt;li>&lt;code>~/rpipress/{magazine}/Books&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>or, using the snap, in&lt;/p>
&lt;ul>
&lt;li>&lt;code>~/snap/rpipress-downloader/current/rpipress/{magazine}&lt;/code>&lt;/li>
&lt;li>&lt;code>~/snap/rpipress-downloader/current/rpipress/{magazine}/Books&lt;/code>.&lt;/li>
&lt;/ul>
&lt;p>Note that the script conveniently let you know the path by printing an
hyperlink in the console,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ rpipress-downloader -m magpi
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Latest MagPi issue is NÂ°95
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">You are up to date
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Your favorite magazines are waiting &lt;span class="k">for&lt;/span> you in file:///home/artivis/snap/rpipress-downloader/5/rpipress
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Please refer to the &lt;a href="https://github.com/artivis/rpipress-downloader" target="_blank" rel="noopener">rpipress-downloader&lt;/a> readme page
for further information.&lt;/p>
&lt;p>Have a good reading!&lt;/p></description></item><item><title>SSH the Raspberry Pi Zero over USB</title><link>https://artivis.github.io/post/2020/pi-zero/</link><pubDate>Mon, 01 Jun 2020 00:00:00 +0000</pubDate><guid>https://artivis.github.io/post/2020/pi-zero/</guid><description>&lt;p>In this post, we will see how to SSH a Raspberry Pi Zero
over USB from a Ubuntu-based host.
Moreover we will make sure the the Pi Zero has access to internet through the host
so that we can install/update some software.&lt;/p>
&lt;h2 id="content">Content&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="#content">Content&lt;/a>&lt;/li>
&lt;li>&lt;a href="#install-raspbian">Install Raspbian&lt;/a>&lt;/li>
&lt;li>&lt;a href="#ssh-over-usb">SSH over USB&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#set-usb-gadget-mode">Set USB Gadget mode&lt;/a>&lt;/li>
&lt;li>&lt;a href="#set-the-connection-to-shared-with-other-computers">Set the connection to Shared with other computers&lt;/a>&lt;/li>
&lt;li>&lt;a href="#set-a-static-mac-address">Set a static MAC address&lt;/a>&lt;/li>
&lt;li>&lt;a href="#set-a-static-ip-address">Set a static IP address&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="install-raspbian">Install Raspbian&lt;/h2>
&lt;p>There exists plenty of tutorials on the topic of installing Raspbian
(see the the &lt;a href="https://www.raspberrypi.org/documentation/installation/installing-images/" target="_blank" rel="noopener">official documentation&lt;/a>)
therefore I will not detail it here.
To summarize, you have to,&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Download &lt;a href="https://www.raspberrypi.org/downloads/raspbian/" target="_blank" rel="noopener">&lt;code>Raspian&lt;/code>&lt;/a> (Lite for headless)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Burn the image on a micro SD card with &lt;a href="https://www.balena.io/etcher/" target="_blank" rel="noopener">&lt;code>Etcher&lt;/code>&lt;/a>&lt;/p>
&lt;p>Before unplugging the card we will enable SSH connections.
To do so, open the &lt;code>boot&lt;/code> partition on the card and simply create
an empty &lt;code>ssh&lt;/code> file:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="nb">cd&lt;/span> /path/to/root/
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">touch ssh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>Plug the card on the Pi Zero&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="ssh-over-usb">SSH over USB&lt;/h2>
&lt;p>With the micro SD card ready we can now plug the USB cable to our host
and Pi Zero.
However, note that while the Pi Zero has two micro USB port,
only one supports USB On-The-Go (OTG). It is this feature that
will allows us to treat the connection as an Ethernet connection.
The port in question is the &lt;strong>innermost&lt;/strong> one,
the one closer to the center of the board, as shown in the image below.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://artivis.github.io/img/post/pizero-usb-host.png" alt="Raspberry Pi Zero USB OTG port" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="set-usb-gadget-mode">Set USB Gadget mode&lt;/h3>
&lt;p>We would like to be able to access the Pi Zero through SSH
from our machine using a USB cable.
To do that we will have to edit two files.&lt;/p>
&lt;p>First, edit the file &lt;code>/boot/config.txt&lt;/code> and append this line at the end:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">dtoverlay=dwc2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Second, we will edit the file &lt;code>/boot/cmdline.txt&lt;/code>.
After &lt;code>rootwait&lt;/code>, we will add&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">modules-load=dwc2,g_ether
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>âš ï¸ pay attention to leave only one space between &lt;code>rootwait&lt;/code>
and the new text otherwise it might not be parsed correctly.&lt;/p>
&lt;/blockquote>
&lt;p>Note that there might already be some text after &lt;code>rootwait&lt;/code>
in which case you still must add the following immediately after &lt;code>rootwait&lt;/code>!
Again, leave a single space after &lt;code>rootwait&lt;/code> but also after &lt;code>g_ether&lt;/code>.&lt;/p>
&lt;p>The Pi Zero is fully configured, we can now configure our host.&lt;/p>
&lt;h3 id="set-the-connection-to-shared-with-other-computers">Set the connection to Shared with other computers&lt;/h3>
&lt;p>On your Linux host, go to the network connections editor.
In the &amp;lsquo;&lt;em>IPv4 Settings&lt;/em>&amp;rsquo; tab,
set &amp;lsquo;&lt;em>Method&lt;/em>:&amp;rsquo; to &amp;lsquo;&lt;em>Shared with other computers&lt;/em>&amp;rsquo;.
Refresh the connection (dis/connect), after what
you should be able to SSH to the Pi Zero.&lt;/p>
&lt;p>To SSH to the Pi Zero, open a terminal on your host and type:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ssh pi@rasberrypi.local
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>You will be prompted for a password, use the
&lt;a href="https://www.raspberrypi.org/documentation/linux/usage/users.md" target="_blank" rel="noopener">default one for user &amp;lsquo;pi&amp;rsquo;&lt;/a>.
And do not forget to change it down the line!&lt;/p>
&lt;p>We are now connected on our board, let&amp;rsquo;s try internet out.
Since we are using the method &amp;lsquo;&lt;em>Shared with other computers&lt;/em>&amp;rsquo;
we should be able to access internet:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">$ ping -c 3 www.google.com
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">PING www.google.com (172.217.13.100) 56(84) bytes of data.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">64 bytes from yul02s04-in-f4.1e100.net (172.217.13.100): icmp_seq=1 ttl=57 time=10.7 ms
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">64 bytes from yul02s04-in-f4.1e100.net (172.217.13.100): icmp_seq=2 ttl=57 time=9.60 ms
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">64 bytes from yul02s04-in-f4.1e100.net (172.217.13.100): icmp_seq=3 ttl=57 time=10.4 ms
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">--- www.google.com ping statistics ---
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">3 packets transmitted, 3 received, 0% packet loss, time 2001ms
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">rtt min/avg/max/mdev = 9.609/10.276/10.783/0.499 ms
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We are live!&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Note&lt;/strong>: On some distro, the &amp;lsquo;&lt;em>Shared with other computers&lt;/em>&amp;rsquo; is
not available from the default settings.
In this case fire up &lt;code>nm-connection-editor&lt;/code> from a terminal instead
of the network connections editor.&lt;/p>
&lt;/blockquote>
&lt;h3 id="set-a-static-mac-address">Set a static MAC address&lt;/h3>
&lt;p>Because we are connecting our Pi Zero as an Ethernet device through
USB OTG, each time the connection is established the board is issued
with a new random MAC address. This can be quickly annoying if we rely
on the MAC address for, e.g. assigning a static IP to our board directly
in our router configurations.
This set up it totally &lt;strong>optional&lt;/strong>.&lt;/p>
&lt;p>In the &lt;code>boot&lt;/code> partition, edit the file &lt;code>cmdline.txt&lt;/code> and append at the end,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">g_ether.host_addr=aa:bb:cc:dd:ee:ff
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>where &lt;code>aa:bb:cc:dd:ee:ff&lt;/code> will be the static MAC address.
We can use for instance the last mac address assigned to the board.
To retrieve it, run &lt;code>ifconfig&lt;/code> on the host machine and look for a
connection along the lines &lt;code>enp0s29xxxxx&lt;/code>.&lt;/p>
&lt;h3 id="set-a-static-ip-address">Set a static IP address&lt;/h3>
&lt;p>We can also choose to assign a static IP address to our board so that we don&amp;rsquo;t
have to look for it every now and then.
To set a static IP address, edit the file &lt;code>/etc/dhcpcd.conf&lt;/code> as follows,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">interface usb0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">static ip_address=10.42.0.42
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">static routers=10.42.0.1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Where &lt;code>10.42.0.42&lt;/code> is your desired static IP address.&lt;/p>
&lt;p>Reboot and have fun!&lt;/p></description></item></channel></rss>