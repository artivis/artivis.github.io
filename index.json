[{"authors":null,"categories":null,"content":"Jérémie Deray is a senior software engineer at Canonical, the company publishing Ubuntu . As part of the robotics team he is working on both ROS and ROS 2 - development, maintenance, dev tools, security, snaps… Before that he worked at PAL Robotics on navigation, perception and a little bit of control, this for various robots - mobile-base, mobile-manipulator, semi-humanoid.\nJérémie is also a PhD in the field of Simultaneous Localization and Mapping (SLAM) applied to industrial mobile-bases. The research has taken place in a collaborative framework between the company PAL Robotics and the Universitat Politècnica De Catalunya (IRI-UPC), both located in the lovely city of Barcelona, Spain. The research work has been supervised by Joan Solà and Juan Andrade Cetto.\n","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://artivis.github.io/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"Jérémie Deray is a senior software engineer at Canonical, the company publishing Ubuntu . As part of the robotics team he is working on both ROS and ROS 2 - development, maintenance, dev tools, security, snaps… Before that he worked at PAL Robotics on navigation, perception and a little bit of control, this for various robots - mobile-base, mobile-manipulator, semi-humanoid.","tags":null,"title":"Jérémie Deray","type":"authors"},{"authors":null,"categories":null,"content":"In this post, we will see how to launch a Linux container that is isolated, not only from other containers, but also from the local network. The container will however have access to internet.\nSuch sandboxed environment can come handy for many use cases. For instance, I found myself in need to provide access to a development environment running on a beefy machine of mine to a remote colleague.\nWhile there are many ways to do this, we will details here a setup that is fairly simple, straightforward and fully managed by LXD. Most importantly, we won’t have to deal with iptables. However, not that it may not be suitable for complex setup, nor does it scale well.\nTo follow along, we’ll assume that you have LXD installed, and some basic experience with it. Let us dive in.\nCreate a dedicated network LXC comes with powerful features when it comes to networking. They may even be a little overwhelming to networking beginners such as myself. Hence this post for futur reference.\nFirst thing first, let us create a container using the default network,\nlxc launch ubuntu:22.04 c0 Let us check that the container is up,\n$ lxc list +------+---------+----------------------+----------------------------------------------+-----------+-----------+ | NAME | STATE | IPV4 | IPV6 | TYPE | SNAPSHOTS | +------+---------+----------------------+----------------------------------------------+-----------+-----------+ | c0 | RUNNING | 10.69.141.197 (eth0) | fd42:3bb:147e:3c99:216:3eff:fe4a:bd59 (eth0) | CONTAINER | 0 | +------+---------+----------------------+----------------------------------------------+-----------+-----------+ Looking at the existing network,\n$ lxc network list +--------+----------+---------+----------------+--------------------------+-------------+---------+---------+ | NAME | TYPE | MANAGED | IPV4 | IPV6 | DESCRIPTION | USED BY | STATE | +--------+----------+---------+----------------+--------------------------+-------------+---------+---------+ | ens3 | physical | NO | | | | 0 | | +--------+----------+---------+----------------+--------------------------+-------------+---------+---------+ | lxdbr0 | bridge | YES | 10.69.141.1/24 | fd42:3bb:147e:3c99::1/64 | | 2 | CREATED | +--------+----------+---------+----------------+--------------------------+-------------+---------+---------+ we can see that the container ip address is in the ip range of the lxdbr0 network.\nAlright, we’ll keep this container aside for now and we will now create an LXD network dedicated to isolation.\nTo do so, issue the following,\nlxc network create lxdbriso This will create a new bridge called lxdbriso.\n$ lxc network list +----------+----------+---------+----------------+---------------------------+-------------+---------+---------+ | NAME | TYPE | MANAGED | IPV4 | IPV6 | DESCRIPTION | USED BY | STATE | +----------+----------+---------+----------------+---------------------------+-------------+---------+---------+ | ens3 | physical | NO | | | | 0 | | +----------+----------+---------+----------------+---------------------------+-------------+---------+---------+ | lxdbr0 | bridge | YES | 10.69.141.1/24 | fd42:3bb:147e:3c99::1/64 | | 2 | CREATED | +----------+----------+---------+----------------+---------------------------+-------------+---------+---------+ | lxdbriso | bridge | YES | 10.75.204.1/24 | fd42:4bb8:a4e4:9d16::1/64 | | 0 | CREATED | +----------+----------+---------+----------------+---------------------------+-------------+---------+---------+ We can note that lxdbriso has a different range than lxdbr0. It is indeed a different network.\nSetting up some containers At this point we can already launch a couple containers using the new network. This will help us make sure that our setup progresses properly.\nlxc launch ubuntu:22.04 c1 -n lxdbriso lxc launch ubuntu:22.04 c2 -n lxdbriso After launching the 2 containers we can list all containers again,\n$ lxc list +------+---------+----------------------+-----------------------------------------------+-----------+-----------+ | NAME | STATE | IPV4 | IPV6 | TYPE | SNAPSHOTS | +------+---------+----------------------+-----------------------------------------------+-----------+-----------+ | c1 | RUNNING | 10.75.204.192 (eth0) | fd42:4bb8:a4e4:9d16:216:3eff:feac:1eea (eth0) | CONTAINER | 0 | +------+---------+----------------------+-----------------------------------------------+-----------+-----------+ | c2 | RUNNING | 10.75.204.31 (eth0) | fd42:4bb8:a4e4:9d16:216:3eff:fe40:5823 (eth0) | CONTAINER | 0 | +------+---------+----------------------+-----------------------------------------------+-----------+-----------+ | c0 | RUNNING | 10.69.141.197 (eth0) | fd42:3bb:147e:3c99:216:3eff:fe4a:bd59 (eth0) | CONTAINER | 0 | +------+---------+----------------------+-----------------------------------------------+-----------+-----------+ and verify that c1 \u0026amp; c2 are on the lxdbriso network.\nAt this point, there is no isolation. You should thus be able to ping in any direction,\n$ lxc exec c1 -- ping c2 -4 …","date":1713398400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1713398400,"objectID":"6136e2fc54d92c3ed75f417e1c4ccfbe","permalink":"https://artivis.github.io/post/2024/lxc-isolated/","publishdate":"2024-04-18T00:00:00Z","relpermalink":"/post/2024/lxc-isolated/","section":"post","summary":"In this post, we will see how to launch a Linux container that is isolated, not only from other containers, but also from the local network. The container will however have access to internet.","tags":["tutorial","LXC","LXD"],"title":"How to isolate an LXC","type":"post"},{"authors":null,"categories":null,"content":"Historically ROS has been developed on top of Ubuntu, relying on the distribution as a stable base providing tools (like GCC, CMake, Python to name a few) and libraries (such as Boost, Eigen, PCL) and following its release cycle (a distribution per year, an LTS every two years). This synergy has worked great for more than 15 years and saw the project and the community behind it vastly grow.\nHowever, being tied to a specific Linux distribution raises all kinds of difficulties. Developing for several ROS distributions can be challenging since they each are tied to an Ubuntu distribution. This challenge increases for ROS newcomers that might not even be familiar with Linux. Similarly, developing ROS on Windows or macOS is anything but a pleasant experience.\nIn this blog post, we will see how one can set up a ROS development environment whatever one’s operating system is. Indeed, using Multipass, an Ubuntu virtual machines’ manager, it has never been easier to quickly spawn a full-fledged VM rocking Ubuntu. Not only that, we made it so that spawning a VM with ROS pre-installed only takes a single command line. Shall we?\nMultipass The first step of our journey is the installation of Multipass. While we summarize hereafter the installation instructions on Linux, you can find the equivalent instructions for Windows and macOS on the documentation.\nOn Linux, Multipass ships as a Snap package allowing it to be installed on dozens of Linux distributions. To install it, hit the following in a terminal,\nsudo snap install multipass And that’s just about it, we’re done. Let us verify that,\n$ multipass version multipass 1.11.0 multipassd 1.11.0 Spawning a first VM With Multipass installed, we can now launch our first VM. And while the installation procedure differs depending on the host OS, the following should run wherever you are.\nAs a practical case, we will place ourselves in the scenario of developing for ROS 2 Humble, therefore using Ubuntu 22.04. To do so, we will enter,\nmultipass launch 22.04 --name humble-vm After hitting enter, the command will spin a little while the VM is being provisioned. A few moments later, a message such as Launched: humble-vm will appear. Our Ubuntu VM is ready, let’s make use of it.\nTo connect to our fresh VM, again it is pretty straightforward. In a terminal enter,\n$ multipass shell humble-vm ubuntu@humble-vm:~$ And boom, here we are!\nubuntu@humble-vm:~$ lsb_release -a No LSB modules are available. Distributor ID: Ubuntu Description: Ubuntu 22.04.2 LTS Release: 22.04 Codename: jammy We are indeed rocking an Ubuntu 22.04 VM after just three command lines. From there we can follow the ROS 2 Humble installation guide as usual and start developing for ROS 2.\nThis being said, mind that by default Multipass VMs are pretty constrained. They only use a single core, a single gig of memory and five gigs of disk space. This will be very limiting for a proper ROS 2 development environment. Of course, we can change all of that either when initially launching the VM as shown in the documentation or even after the facts by running the following commands,\nmultipass stop humble-vm multipass set local.humble-vm.cpus=4 multipass set local.humble-vm.disk=50G multipass set local.humble-vm.memory=8G multipass start humble-vm While we could keep on going, through the installation hassle of ROS 2 Humble, I promised you a one-liner to set up a fresh ROS development environment, didn’t I?\nOne-liner to ROS development environment Multipass in itself is already pretty handy as it is. Three command lines and we find ourselves in a fresh Ubuntu VM. But let’s take it a notch further, shall we? How about three command lines and we find ourselves in a fresh ROS development environment?\nTo do so, we developed a Multipass blueprint for ROS 2 Humble. A blueprint is a configuration file detailing a set of parameters and instructions that drive the setup of a customized environment. All Multipass environments can be listed as follows,\n$ multipass find Image Aliases Version Description … core22 20230119 Ubuntu Core 22 … 22.04 jammy,lts 20230302 Ubuntu 22.04 LTS … docker 0.4 A Docker environment with Portainer and related tools … ros-noetic 0.1 A development and testing environment for ROS Noetic. ros2-humble 0.1 A development and testing environment for ROS 2 Humble. Among other things, we will find a Core22 image, the 22.04 image we used above, but also a Docker-ready environment and what’s of interest to us now, a ROS Noetic and a ROS 2 Humble environments. Let us see what this is about.\nFirst, let’s cleanup a bit. We will stop, delete and purge our previous VM,\nmultipass stop humble-vm multipass delete --purge humble-vm From a clean sheet, we will now launch our ROS 2 Humble VM making use of the predefined custom environment,\nmultipass launch ros2-humble --name humble-vm Again this will take a little while. A little more than previously since this time, not only are we spawning an Ubuntu VM but also installing ROS 2 …","date":1680739200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1680739200,"objectID":"37e664ed086cb4ea037649854f42ec3f","permalink":"https://artivis.github.io/post/2023/multipass_ros_blueprint/","publishdate":"2023-04-06T00:00:00Z","relpermalink":"/post/2023/multipass_ros_blueprint/","section":"post","summary":"Historically ROS has been developed on top of Ubuntu, relying on the distribution as a stable base providing tools (like GCC, CMake, Python to name a few) and libraries (such as Boost, Eigen, PCL) and following its release cycle (a distribution per year, an LTS every two years).","tags":["tutorial","ROS","ROS 2","multipass"],"title":"ROS, wherever you are","type":"post"},{"authors":null,"categories":null,"content":"ROS 2 Humble Hawksbill is out!\nCongratulations to Open Robotics and through them to the entire ROS 2 community. This is really quite an event as it marks an important milestone: it is the first 5 year LTS release for ROS 2. The release of maturity as people say.\nROS 2 Humble officially supports Ubuntu 22.04, but chance is, you haven’t made that jump yet. So in this post we will see how to set it up in an LXD container so that we can start playing working on our good old machine.\nWe’ve covered how to get started with LXD in numerous previous posts; so here we will only go over the commands to get started as quickly and conveniently as possible.\nSetting up LXD LXD is a manager for LXC.\nWith this out of the way, the simplest way to install it is to use the snap package:\nsudo snap install lxd --channel=5.0/stable Note that we are specifying the use of the recently released 5.0 LTS version.\nLet us now configure LXD,\nsudo lxd init --minimal The minimal setup will configure LXD with default options. You may find more information about this in the online documentation.\nLaunching a first container To make sure that everything works fine, let us try to launch a first container rocking Ubuntu 22.04,\nlxc launch ubuntu:22.04 first-container Is it running?\n$ lxc list +---------------------+---------+----------------------+-----------------------------------------------+-----------+-----------+ | NAME | STATE | IPV4 | IPV6 | TYPE | SNAPSHOTS | +---------------------+---------+----------------------+-----------------------------------------------+-----------+-----------+ | first-container | RUNNING | 10.190.86.230 (eth0) | fd42:1726:4b4d:8cd3:216:3eff:fed8:7a69 (eth0) | CONTAINER | 0 | +---------------------+---------+----------------------+-----------------------------------------------+-----------+-----------+ It seems so; then let’s try to get a shell inside the container,\n$ lxc shell first-container root@ros2-humble:~ lsb_release -a No LSB modules are available. Distributor ID: Ubuntu Description: Ubuntu 22.04 LTS Release: 22.04 Codename: jammy We’re in, running 22.04. Everything looks good!\nFrom there we could simply follow the installation instructions from the ROS 2 Humble documentation. But where is the fun in that? Instead we will create a LXD profile that will do all the lifting for us every time we will create a new container.\nAn Humble profile First we need to create a profile,\nlxc profile create ros2-humble We will then edit it to add the bits we need. But rather than editing the profile itself, we will work on a good-old yaml file, located on our machine. The reason is that it is more convenient and most importantly, we will be able to carry that yaml file and re-use it on other machines. Let’s create that profile,\nmkdir -p ~/lxc_dotfiles/profile/ touch ~/lxc_dotfiles/profile/ros2-humble.yml which we populate as follows,\nconfig: user.user-data: | #cloud-config # Add the ROS 2 sources apt: sources: ros2: source: \u0026#34;deb [arch=amd64] http://repo.ros2.org/ubuntu/main jammy main\u0026#34; keyid: C1CF 6E31 E6BA DE88 68B1 72B4 F42E D6FB AB17 C654 package_upgrade: true packages: # dev - vim - silversearcher-ag # ROS 2 dev - locales - curl - gnupg - lsb-release - build-essential - cmake - git - python3-argcomplete - python3-colcon-common-extensions - python3-flake8 - python3-flake8-blind-except - python3-flake8-builtins - python3-flake8-class-newline - python3-flake8-comprehensions - python3-flake8-deprecated - python3-flake8-docstrings - python3-flake8-import-order - python3-flake8-quotes - python3-pip - python3-pytest - python3-pytest-cov - python3-pytest-repeat - python3-pytest-rerunfailures - python3-rosdep - python3-setuptools - python3-vcstool - wget # ROS 2 packages - ros-humble-ros-core runcmd: # System setup - \u0026#34;locale-gen en_US en_US.UTF-8\u0026#34; - \u0026#34;update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8\u0026#34; - \u0026#34;export LANG=en_US.UTF-8\u0026#34; # # Fetch ROS 2 sources - [su, ubuntu, -c, \u0026#34;mkdir -p /home/ubuntu/ros2_ws/src\u0026#34;] - [su, ubuntu, -c, \u0026#34;wget https://raw.githubusercontent.com/ros2/ros2/master/ros2.repos -O /home/ubuntu/ros2_ws/ros2.repos\u0026#34;] - [su, ubuntu, -c, \u0026#34;vcs import /home/ubuntu/ros2_ws/src \u0026lt; /home/ubuntu/ros2_ws/ros2.repos\u0026#34;] # # Install deps - [su, ubuntu, -c, \u0026#34;sudo rosdep init\u0026#34;] - [su, ubuntu, -c, \u0026#34;rosdep update\u0026#34;] - [su, ubuntu, -c, \u0026#34;rosdep install --from-paths /home/ubuntu/ros2_ws/src --ignore-src -y --skip-keys \u0026#39;fastcdr rti-connext-dds-6.0.1 urdfdom_headers gazebo_ros_pkgs\u0026#39; --rosdistro humble\u0026#34;] final_message: \u0026#34;ROS 2 Humble Hawksbill dev container ready!\u0026#34; description: \u0026#34;A profile to automatically a ROS 2 Humble dev container.\u0026#34; devices: {} name: ros2-humble used_by: [] We will not go into the details of this profile, note simply that it takes advantage of LXD support of cloud-init to set up the ppa, install packages and fetch the ROS 2 Humble source code. Alright, let us carry on and launch our Humble container. But let’s not forget to edit our LXD profile from the yaml file we have just created,\nlxc profile edit ros2-humble \u0026lt; …","date":1653264e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1653264e3,"objectID":"8192b0967dc50dc45c65356e77e60d3d","permalink":"https://artivis.github.io/post/2022/ros2-humble/","publishdate":"2022-05-23T00:00:00Z","relpermalink":"/post/2022/ros2-humble/","section":"post","summary":"ROS 2 Humble Hawksbill is out!\nCongratulations to Open Robotics and through them to the entire ROS 2 community. This is really quite an event as it marks an important milestone: it is the first 5 year LTS release for ROS 2.","tags":["tutorial","ROS 2","Humble","LXC","LXD"],"title":"Setting up ROS 2 Humble with LXD","type":"post"},{"authors":["Joan Solà","Joan Vallvé","Joaquim Casals","Jérémie Deray","Médéric Fourmy","Dinesh Atchuthan","Andreu Corominas-Murtra","Juan Andrade-Cetto"],"categories":null,"content":"","date":1644796800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1644796800,"objectID":"6d0a63e06774f203cbfcb23bbd253a12","permalink":"https://artivis.github.io/publication/sola-22/","publishdate":"2022-02-14T22:12:35.023827Z","relpermalink":"/publication/sola-22/","section":"publication","summary":"This letter introduces Wolf , a C++ estimation framework based on factor graphs and targeted at mobile robotics. Wolf can be used beyond SLAM to handle self-calibration, model identification, or the observation of dynamic quantities other than localization. The architecture of Wolf allows for a modular yet tightly-coupled estimator. Modularity is enhanced via reusable plugins that are loaded at runtime depending on application setup. This setup is achieved conveniently through YAML files, allowing users to configure a wide range of applications without the need of writing or compiling code. Most procedures are coded as abstract algorithms in base classes with varying levels of specialization. Overall, all these assets allow for coherent processing and favor code re-usability and scalability. Wolf can be used with ROS , and is made publicly available and open to collaboration.","tags":null,"title":"WOLF: A modular estimation framework for robotics based on factor graphs","type":"publication"},{"authors":null,"categories":null,"content":"In this post we will see how the Pi Pico can natively speak to a ROS2 graph using micro-ROS. We will set up a project in VSCode, compile and upload it to the microcontroller. We thus assume that you are somewhat familiar with ROS2 development and VSCode.\nWhat is this all about? The Raspberry Pi Pico The Raspberry Pi Pico, announced in late January 2021, is the newest release of the Raspberry Pi Foundation which received a ton of attention (a quick search on Google and/or Youtube will convince you). And that’s for a good reason. Compared to its well known predecessors, this new board differs in two major ways: it is an in-house designed open-hardware microcontroller! Yes, the chip itself is designed by the Pi’s engineers and it is fully open-hardware. And as usually with the Pi foundation, it is incredibly affordable at just 4$.\nThe details concerning the board itself, the differences between microprocessor and microcontroller, the 101 getting started or what can the Pi Pico do; all of that is beyond the scope of this post. But I strongly encourage you having a look for yourself, whether you are familiar with microcontrollers or not.\nmicro-ROS In the ROS (1) realm, microcontrollers have always been sort of second class citizens. They can’t interact directly with the ROS graph and developers have to rely on libraries such as rosserial. But ROS2 is a whole new world and things are changing.\nmicro-ROS puts ROS 2 onto microcontrollers, making them first class participants of the ROS 2 environment.\nThe micro-ROS project is an effort led by big industrial names such as Bosch, eProsima, Fiware Foundation, notably through the OFERA H2020 project, and a myriad of partners and collaborators including e.g. Amazon and Canonical.\nSo what is it? It is essentially a thin wrapper (see its design document) on top of ‘DDS for eXtremely Resource Constrained Environments’ (DDS-XRCE), running on a real-time OS, allowing microcontrollers to ‘speak’ to a ROS2 graph (the usual talker/listener) using an optimized subset of the DDS protocol. It relies on a ‘bridged’ communication architecture with a ‘broker’ named the ‘micro-ros-agent’. The agent is in charge of the interfacing between the ROS2 graph and one or several micro-ROS devices.\nMore details can be found on the micro-ROS website including how it compares/differs from rosserial (see here and here).\nGetting started Alright, so now that we have clarified a couple terms, let us get started, step by step, with micro-ROS on Pi Pico with the official example available on github. Note that for this tutorial I am running Ubuntu 20.04 with the VSCode snap.\nIf you are not running Ubuntu 20.04 yet, you could consider using a LXD container. You can refer to my previous post ‘ROS Noetic development workflow in LXC’ to help you get started setting up the container.\nInstalling dependencies Let’s start simple by installing the couple necessary dependencies,\nsudo apt install build-essential cmake gcc-arm-none-eabi libnewlib-arm-none-eabi doxygen git python3 Fetching the sources We will now create a workspace and fetch all the sources,\nmkdir -p ~/micro_ros_ws/src cd ~/micro_ros_ws/src git clone --recurse-submodules https://github.com/raspberrypi/pico-sdk.git git clone https://github.com/micro-ROS/micro_ros_raspberrypi_pico_sdk.git The first repository is the Pi Pico SDK provided by the Pi foundation. The second contains a precompiled micro-ROS stack together with a hello-world-like example.\nSetting up VSCode Let us now open the example in VSCode and set it up. To follow along, you will need two VSCode extensions that are rather common for C++ development. These extensions are the C++ extension and CMake tools for VSCode. After installing them, we will create a configuration file for CMake tools and set a variable so that our project knows where to find the Pi Pico SDK. To do so, simply type,\ncd ~/micro_ros_ws/src/micro_ros_raspberrypi_pico_sdk mkdir .vscode touch .vscode/settings.json Open the newly created file with your favorite editor,\nvi .vscode/settings.json and add the following,\n{ \u0026#34;cmake.configureEnvironment\u0026#34;: { \u0026#34;PICO_SDK_PATH\u0026#34;: \u0026#34;/home/artivis/micro_ros_ws/src/pico-sdk\u0026#34;, }, } This variable is an environment variable that is only passed to CMake at configuration time. See the CMake-Tools documentation for more info.\nLet us now open it,\ncode . Before running the CMake configuration and build it, we must select the appropriate ‘kit’ (maybe VSCode has already asked you to do so). Open the palette (ctrl+shift+p) and search for \u0026#39;CMake: Scan for Kits\u0026#39; and then \u0026#39;CMake: Select a Kit\u0026#39; and make sure to select the compiler we’ve installed above, that is \u0026#39;GCC for arm-non-eabi\u0026#39;.\nWe’re all set, let us build the example! Open the palette again and hit \u0026#39;CMake: Build\u0026#39;.\nRunning the example Wait a minute. What does it do? Right, let’s break down very briefly what the example does. It sets up a node called \u0026#39;pico_node\u0026#39;, then a publisher publishing a \u0026#39;std_msgs/msg/int32.h\u0026#39; message on topic \u0026#39;pico_publisher\u0026#39;, a …","date":1621382400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1621382400,"objectID":"4d1951342225bc7e104924acfe1b4e7c","permalink":"https://artivis.github.io/post/2021/pi-pico-uros-getting-started/","publishdate":"2021-05-19T00:00:00Z","relpermalink":"/post/2021/pi-pico-uros-getting-started/","section":"post","summary":"In this post we will see how the Pi Pico can natively speak to a ROS2 graph using micro-ROS. We will set up a project in VSCode, compile and upload it to the microcontroller.","tags":["tutorial","Raspberry Pi","Pi Pico","ROS2","micro-ROS","VSCode"],"title":"Getting started with micro-ROS on the Pi Pico","type":"post"},{"authors":null,"categories":null,"content":"In this post we will see how to wire up an HC-SR04 range sensor to the Raspberry Pi Pico and publish its readings to the ROS 2 graph using micro-ROS. This builds upon the previous post ‘Getting started with micro-ROS on the Pi Pico’, as such I’d encourage you to read it first if you are not already familiar with the topic.\nA sensor you said? In this tutorial, we will make use of one of the most common sensors in robotics, a sonar. These sensors are cheap, fairly simple to use and surprisingly precise under favorable circumstances. Sonars are used to measure distances and can therefore be used to detect and locate obstacles so that one can make sure its robot does not run into nearby things. It is no mystery why they are so incredibly popular.\nSo, what’s a sonar, how does it work, which one should I pick?\n“I’m Bat(sensor)” A sonar is an echolocation sensor which allows for measuring distances. To keep things simple to digest, sonars work the same way as bats do. Nah they don’t fly, hunting bugs at dawn; nor do they fight crime. I obviously meant the same way as bats perceive the world. A sonar is composed of an emitter and a receiver. The former emits an ultrasound signal, which will bounce off of facing obstacles, back at the receiver. Measuring the time difference between the signal emission and reception, one can easily calculate the distance travelled by the sound wave and thus the distance to the obstacle that reverberated the sound.\nThis technology can suffer from all kind of issues if, for example, the sound wave is reverberated away from the sensor, or if it is reverberated back to the sensor by two obstacles at different distances, or if it is absorbed by some sound dampening material.\nIf this is still unclear or you want to know more about it, I’ll redirect you to your favorite web search engine as it is a little out of the scope of this post.\nWhich sonar model to pick? There exists plenty different models of sonars, fortunately most of them works the same way. Furthermore they can be found for a few bucks per unit on the internet. Head on over to your favorite electronics supplier and you’re sure to find them for sale.\nI’d recommend you use the ‘HC-SR04P’ model which is the 3.3V variant of the immensely popular ‘HC-SR04’ (5V). It is this model (the ‘HC-SR04P’) I will be using in this post. Given its very small power consumption, it can be powered up directly from the Pi Pico and thus the whole setup can simply be powered from the USB cable. In case you are using a 5V package, make sure to adapt the wiring described below or else you are risking damages to your Pi Pico! For reference, I ordered a lot of 5 units for less than 10$ including shipping. Including the Pi Pico price, that’s a lot of sensing for the price!\nWiring up the sonar to the Pi Pico The ‘HC-SR04P’ board comes with four pins labelled ‘Vcc’, ‘Gnd’, ‘Trig’ and ‘Echo’. As you’ve already guessed, the Vcc and Gnd pins are for the 3.3V line and the ground respectively, while ‘Trig’ is used to trigger the sensor and ‘Echo’ reports the reception of the echo (the reception of the sound wave that bounced off of an obstacle).\nFrom there, and referring to the Pi Pico pinout, the wiring is straight forward:\nconnect Pico’s pin 36 (3V3 OUT) to the sonar’s ‘Vcc’ connect Pico’s pin 38 (GND) to the sonar’s ‘Gnd’ connect Pico’s pin 9 (GPIO 6) to the sonar’s ‘Echo’ connect Pico’s pin 10 (GPIO 7) to the sonar’s ‘Trig’ This setup is depicted in the figure below.\nAs far as the hardware goes, we’re done. Let us move to the software.\nMicro code for micro-ROS We’ve seen in the ‘previous post’ how to set up VSCode for programming micro-ros, and how to compile and flash a program on the Pi Pico. We’ll thus refer to the aforementioned post on how to do all that and skip it here. Similarly, we’ll skip all the boilerplate code and only show the bits specific to our application. However, know that this example (and more) is fully available on github at artivis/mico_ros.\nAlright, let’s dive a little. Our application is essentially composed of two functions, one that triggers and reads the sensor, and a second, the timer callback, which calls the first, fill up a ROS message and publishes it:\n... // The GPIO pins to which the sonar is wired #define GPIO_ECHO 6 #define GPIO_TRIGGER 7 /** * @brief Get the range value in meter. */ float read_range() { // Send an impulse trigger of 10us gpio_put(GPIO_TRIGGER, 1); sleep_us(10); gpio_put(GPIO_TRIGGER, 0); // Read how long is the echo uint32_t signaloff, signalon; do { signaloff = time_us_32(); } while (gpio_get(GPIO_ECHO) == 0); do { signalon = time_us_32(); } while (gpio_get(GPIO_ECHO) == 1); // Actual echo duration in us const float dt = signalon - signaloff; // distance in meter: // echo duration (us) x speed of sound (m/us) / 2 (round trip) return dt * 0.000343 / 2.0; } ... /** * @brief Read the range from the sensor, * fill up the ROS message and publish it. */ void timer_callback(rcl_timer_t *timer, int64_t …","date":1615507200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1615507200,"objectID":"0888a684eacd5d63bd108ef62df75f84","permalink":"https://artivis.github.io/post/2021/pi-pico-uros-sonar/","publishdate":"2021-03-12T00:00:00Z","relpermalink":"/post/2021/pi-pico-uros-sonar/","section":"post","summary":"In this post we will see how to wire up an HC-SR04 range sensor to the Raspberry Pi Pico and publish its readings to the ROS 2 graph using micro-ROS. This builds upon the previous post ‘Getting started with micro-ROS on the Pi Pico’, as such I’d encourage you to read it first if you are not already familiar with the topic.","tags":["tutorial","Raspberry Pi","Pi Pico","ROS2","micro-ROS","sensors"],"title":"Publishing sonar readings with micro-ROS on the Raspberry Pi Pico","type":"post"},{"authors":null,"categories":null,"content":"In this post we will discover the great magazines edited under the Raspberry Pi Press umbrella and discuss how to easily access them all.\nThe Raspberry Pi Press magazines The Raspberry Pi Press is a part of the Raspberry Pi Foundation and the publisher of a great deal of magazines and books. Among the many magazines edited, some are freely available for download,\nHackSpace is a monthly publication dedicated to those who love to make things and learn while doing it. HelloWorld is published three times a year and targets educators of the computing and digital world. MagPi is the official magazine of the Raspberry Pi and is loaded with stories and project based on the single board computer. Published every month, the latest issue is numbered N°95 as of the time of writing, making it an incredible source of inspiration. Wiredframe is published every 2 weeks and is entirely dedicated to video games. But unlike other video game magazines, it offers to look at how they are made, who make them and offer a lot of resources to get started writing your own games. On top of that, The Raspberry Pi Press also publishes many great books.\nEach magazine can be bought online and shipped around the globe. One can also sign for a yearly subscription, offering some discount and/or goodies. At the same time, issues are freely available to download in pdf from the magazine websites.\nBookshelf Recently the Raspberry Pi Foundation presented the Raspberry Pi OS, a rebranding of Raspbian, highlighting some of its novelties. Among those novelties, they showcased a neat little app named Bookshelf that allows you to browse and download the issues of several magazines edited by the Raspberry Pi Press.\nThe application is a simple interface listing all issues of each magazine but also some of the books. It allows for simply downloading any issue by simply clicking on the desired cover.\nUnfortunately this great app is only available through the Pi OS archive and its source code is not public at the time of writing. One can still download the deb package and install it manually. To do so, visit the app archive and look for the latest version of the debian package for your machine architecture. At the moment it is rp-bookshelf_0.4_amd64.deb for common computers. From there, we can simply download the debian and install it,\nwget http://archive.raspberrypi.org/debian/pool/main/r/rp-bookshelf/rp-bookshelf_0.4_amd64.deb dpkg -i rp-bookshelf_0.4_amd64.deb To launch the app simply type,\nrp-bookshelf Altho this procedure works fine, it is a little unpleasant. Furthermore, I personally don’t care much about the GUI and I’d rather prefer to automatically download the latest issues I care for. If you feel the same, keep on reading.\nrpipress-downloader The Raspberry Pi Press Store was recently entirely redesigned bringing some uniformization across all the magazine websites. That allows us to write a small web scrapping script to automatically download the latest (or all) issues and books of our favorite magazine(s).\nSo I went ahead and did just that, writing a small Python script that you can find on Github, or conveniently install as a Snap as follows,\nsudo snap install rpipress-downloader Its use it pretty simple, launch the script in a terminal and by default it will automatically search and download the latest issue of all aforementioned magazines.\nFurther options let you:\nspecify which magazine to download\nrpipress-downloader --magazines magpi hackspace download all issues,\nrpipress-downloader --all download the books too,\nrpipress-downloader --books combine options so that,\nrpipress-downloader -a -m magpi -b will download all MagPi issues and books.\nIssues and books are saved respectively in\n~/rpipress/{magazine} ~/rpipress/{magazine}/Books or, using the snap, in\n~/snap/rpipress-downloader/current/rpipress/{magazine} ~/snap/rpipress-downloader/current/rpipress/{magazine}/Books. Note that the script conveniently let you know the path by printing an hyperlink in the console,\n$ rpipress-downloader -m magpi Latest MagPi issue is N°95 You are up to date Your favorite magazines are waiting for you in file:///home/artivis/snap/rpipress-downloader/5/rpipress Please refer to the rpipress-downloader readme page for further information.\nHave a good reading!\n","date":1594252800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1594252800,"objectID":"9e002b88a15bd0c002572e16d17175da","permalink":"https://artivis.github.io/post/2020/rpipress/","publishdate":"2020-07-09T00:00:00Z","relpermalink":"/post/2020/rpipress/","section":"post","summary":"In this post we will discover the great magazines edited under the Raspberry Pi Press umbrella and discuss how to easily access them all.\nThe Raspberry Pi Press magazines The Raspberry Pi Press is a part of the Raspberry Pi Foundation and the publisher of a great deal of magazines and books.","tags":["tutorial","Raspberry Pi","press","free magazines"],"title":"Downloading Raspberry Pi Press issues","type":"post"},{"authors":null,"categories":null,"content":"The 5th of June 2020 marks the release of ROS 2 Foxy Fitzroy, a 3 years long-term support (LTS) release and the first ROS 2 distribution to target Ubuntu 20.04.\nAs summarized in the ROS Discourse post, Foxy comes loaded with performance improvements, new features, and maybe most importantly, with tutorials! Get a full tour of the novelties by heading down to the Foxy release page.\nNow, you may be very excited about ROS 2 Foxy but you, just as I, haven’t moved to Ubuntu 20.04 just yet. But that will not stop us from getting our hands on all the goodies this new release offers.\nIndeed, in this post we will see how to install ROS 2 Foxy Fitzroy in a LXD container so that we can develop against the latest ROS 2 release without the need to upgrade our computer just yet.\nHereafter we will assume that your are familiar with the command terminal and that LXD is already installed on your machine. If you are new to LXD or looking to improve your ROS development with it, have a look to this post ‘ROS Noetic development workflow in LXC’.\nAlright let us get started.\nSpawning an Ubuntu 20.04 LXD container So the first thing we have to do is to create a LXD container based on an Ubuntu 20.04 image. To do so we issue the following command,\nlxc launch ubuntu:20.04 ros2-foxy It creates and starts a container named ‘ros2-foxy’ based on an Ubuntu 20.04 image. So far so good.\nNow to start a shell in our fresh container we will type,\nlxc exec ros2-foxy -- sudo --login --user ubuntu We are now inside our container, logged as the non-root user ‘ubuntu’. Note that if the last command looks a bit unfriendly to you, you can make it a ’lxc’ alias (learn more about it in the aforementioned LXD post).\nNow that our container is up and running, we shall install Foxy.\nInstalling ROS 2 Foxy Fitzroy Inside our container, we will first add the ROS packages repository to our sources. Starting with the key,\nsudo apt-key adv --fetch-keys https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc then the repository,\nsudo apt-add-repository http://packages.ros.org/ros2/ubuntu In case of trouble, you can also refer to the official installation guide.\nWe are all set to install Foxy!\nFor the installation, we can choose either of two options; we can choose to install only the base components, e.g. the communication libraries, message packages, command line tools, etc…\nsudo apt install ros-foxy-ros-base or we can install the base + RViz, demos and tutorials,\nsudo apt install ros-foxy-desktop You can pick any depending on your needs. If you are not sure which to pick, I would recommend you install the desktop version in order to have all the tools you may need already installed. However, note that if you intend to use some graphical applications in your container, you have to take an extra step and set up some parameters for your container. All of this is detailed in the aforementioned LXD post.\nSince the container was created especially for Foxy, we will automatically source it in our ‘.bashrc’,\necho \u0026#34;source /opt/ros/foxy/setup.bash\u0026#34; \u0026gt;\u0026gt; ~/.bashrc Every times we will log into our container, ROS 2 Foxy will be sourced and we will be ready to develop!\nAt last, we can install the Python package ‘argcomplete’ to enable autocompletion for the ROS 2 command line tools. This is totally optional, but also totally recommended:\nsudo apt install python3-argcomplete With Foxy installed, all there is left to do is to take it for a spin.\nQuick test We will try the simple talker-listener demo, mixing cpp and Python to make sure that the installation went fine and that we can start developing right away. Note that if you installed the ‘base’ version in the previous section, you will need to install the following packages,\nsudo apt install ros-foxy-demo-nodes-cpp ros-foxy-demo-nodes-py For the test, let us start fresh and close our current shell. We will then open 2 new ones, one for the publisher and one for the subscriber.\nTo start the publisher in the first shell enter,\n$ ros2 run demo_nodes_cpp talker [INFO] [1591461939.792327469] [talker]: Publishing: \u0026#39;Hello World: 1\u0026#39; [INFO] [1591461940.792228229] [talker]: Publishing: \u0026#39;Hello World: 2\u0026#39; [INFO] [1591461941.792184798] [talker]: Publishing: \u0026#39;Hello World: 3\u0026#39; ... and we can see that it starts publishing messages right away.\nTo start the listener in the second shell enter,\n$ ros2 run demo_nodes_py listener [INFO] [1591461964.793113956] [listener]: I heard: [Hello World: 5] [INFO] [1591461965.792782570] [listener]: I heard: [Hello World: 6] [INFO] [1591461966.792823099] [listener]: I heard: [Hello World: 7] ... and we can see that it receives messages right away as well.\nWe are all set!\n","date":1591401600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1591401600,"objectID":"9d67f85c814c83f333e6aed72f528a53","permalink":"https://artivis.github.io/post/2020/ros-foxy-install/","publishdate":"2020-06-06T00:00:00Z","relpermalink":"/post/2020/ros-foxy-install/","section":"post","summary":"The 5th of June 2020 marks the release of ROS 2 Foxy Fitzroy, a 3 years long-term support (LTS) release and the first ROS 2 distribution to target Ubuntu 20.04.","tags":["tutorial","ROS 2","Foxy","LXC","LXD"],"title":"Get started with ROS 2 Foxy today with LXD","type":"post"},{"authors":null,"categories":null,"content":"In this post, we will see how we can easily manage our personal configuration files - a.k.a. dotfiles. Yeah dotfiles, named after there common ~/.my_config form, you know, all of those small configuration files lying across our $HOME.\nBecause there is no place like $HOME\nBecause we are spending so much time on our machine, be it for work or for fun (both at the same time if you are lucky), we love to tweak our environment to our taste and needs. Change the UX, create some aliases, use some dark theme and what not, most if not all of these are saved in some configuration files somewhere. And since we spent so much time making a home for ourselves, wouldn’t it be great if we could quickly set it up again on a different computer? Change the house but keep the furniture and decorations? This is precisely what we are going to set up here.\nPicking a dotfiles manager Looking on the web for a dotfiles manager, you may find many of them - see a whole list of them here. Most of them work off the same principles, being a small set of utils to help manage our dotfiles. Management includes most importantly versioning, often through git and the installation of the files to their correct location as they are more than often expected to be found at a given path. You may want to give a look at the aforementioned list of managers and pick one that best answers your needs and expectations. Note that many are interchangeable.\nIn this post we settled using homeshick. There are two main reasons for this choice. Firstly, it is entirely written in bash, making it usable virtually anywhere. Secondly, it ‘installs’ dotfiles on our system using symlinks rather than hard copies. The files thus exist in a single place. Some other nice features includes, being git-based, being cli-based, supporting multi dotfiles repos. It has to be noted tho that the project is not in a really active development and not very feature rich compared to other solutions. It is a thin-layer that does the job.\nAlright so how do we get started?\nBuilding our castle homeshick relies around the concept of castles which are nothing more than git repositories. A castle contains all of our dotfiles which are organized with the same layout as our home directory. But before building our castle, we need to install the appropriate tool. To install homeshick, nothing easier, we simply clone its repository in our home:\ngit clone https://github.com/andsens/homeshick.git $HOME/.homesick/repos/homeshick And we are done. Now to use it, we only have to source it, e.g. directly in our .bashrc,\necho \u0026#34;source ~/.homesick/repos/homeshick/homeshick.sh\u0026#34; \u0026gt;\u0026gt; ~/.bashrc We can also source its tab completion tool to ease our life,\necho \u0026#34;source ~/.homesick/repos/homeshick/completions/homeshick-completion.bash\u0026#34; \u0026gt;\u0026gt; ~/.bashrc Alright, we are done with the installation, let us start creating the said castle.\nFirst we create a new local git repo through homeshick cli tool,\n$ homeshick generate dotfiles This creates an empty castle named ‘dotfiles’ in ~/.homesick/repos/dotfiles/. To populate our castle with a dotfile, we make use of the ’track’ command:\nhomeshick track {castle} {dotfile} To track our first file, say e.g. .bashrc, we simply issue,\nhomeshick track dotfiles ~/.bashrc The command copies the file in our castle at ~/.homesick/repos/dotfiles/home/.bashrc and replaces the original file with a symlink to the copy.\nNow all we have to do is to commit our change and save our castle online,\nTo move to our local repository, we enter,\n$ homeshick cd dotfiles and we can now use the usual git commands,\ngit add . git commit -m \u0026#39;add .bashrc\u0026#39; Let us save our castle online, e.g. on GitHub,\ngit remote add origin git@github.com:user/dotfiles.git git push -u origin master We may now repeat this operation for each and every configuration file we would like to save. With our castle safely backed up online, we will now see how we can quickly set up our environment on a new machine.\nQuickly setting up a new machine Whether you bought a new computer or nuked your old hardware with a fresh new distro, you will now witness the true power of homeshick.\nTo install our cosy environment on a fresh distro, all we have to do is,\nInstall homeshick\ngit clone https://github.com/andsens/homeshick.git $HOME/.homesick/repos/homeshick source ~/.homesick/repos/homeshick/homeshick.sh Import our castle\nhomeshick clone git@github.com:user/dotfiles.git Let homeshick works its magic\nhomeshick link dotfiles Voila! Home sweet home.\nOf course this post is only a quick overview of a given dotfiles manager. I won’t detail here all of its options and features and let you discover them for yourself in its wiki. As mentioned previously many dotfiles managers rely on a git repository and the same layout as homeshick so you can get started with it and later move to another one which better fits your needs.\nAt this point you may be wondering if this is really worth it given that you probably install a fresh distro every 2 years or so and …","date":1591401600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1591401600,"objectID":"e2a84bd28e0b382911532f574e4380e4","permalink":"https://artivis.github.io/post/2020/dotfiles/","publishdate":"2020-06-06T00:00:00Z","relpermalink":"/post/2020/dotfiles/","section":"post","summary":"In this post, we will see how we can easily manage our personal configuration files - a.k.a. dotfiles. Yeah dotfiles, named after there common ~/.my_config form, you know, all of those small configuration files lying across our $HOME.","tags":["tutorial","dotfiles","HOME","homeshick","LXC","LXD"],"title":"Managing dotfiles","type":"post"},{"authors":null,"categories":null,"content":"In this post, we will see how to SSH a Raspberry Pi Zero over USB from a Ubuntu-based host. Moreover we will make sure the the Pi Zero has access to internet through the host so that we can install/update some software.\nInstall Raspbian There exists plenty of tutorials on the topic of installing Raspbian (see the the official documentation) therefore I will not detail it here. To summarize, you have to,\nDownload Raspian (Lite for headless)\nBurn the image on a micro SD card with Etcher\nBefore unplugging the card we will enable SSH connections. To do so, open the boot partition on the card and simply create an empty ssh file:\ncd /path/to/root/ touch ssh Plug the card on the Pi Zero\nSSH over USB With the micro SD card ready we can now plug the USB cable to our host and Pi Zero. However, note that while the Pi Zero has two micro USB port, only one supports USB On-The-Go (OTG). It is this feature that will allows us to treat the connection as an Ethernet connection. The port in question is the innermost one, the one closer to the center of the board, as shown in the image below.\nSet USB Gadget mode We would like to be able to access the Pi Zero through SSH from our machine using a USB cable. To do that we will have to edit two files.\nFirst, edit the file /boot/config.txt and append this line at the end:\ndtoverlay=dwc2 Second, we will edit the file /boot/cmdline.txt. After rootwait, we will add\nmodules-load=dwc2,g_ether ⚠️ pay attention to leave only one space between rootwait and the new text otherwise it might not be parsed correctly.\nNote that there might already be some text after rootwait in which case you still must add the following immediately after rootwait! Again, leave a single space after rootwait but also after g_ether.\nThe Pi Zero is fully configured, we can now configure our host.\nSet the connection to Shared with other computers On your Linux host, go to the network connections editor. In the ‘IPv4 Settings’ tab, set ‘Method:’ to ‘Shared with other computers’. Refresh the connection (dis/connect), after what you should be able to SSH to the Pi Zero.\nTo SSH to the Pi Zero, open a terminal on your host and type:\nssh pi@rasberrypi.local You will be prompted for a password, use the default one for user ‘pi’. And do not forget to change it down the line!\nWe are now connected on our board, let’s try internet out. Since we are using the method ‘Shared with other computers’ we should be able to access internet:\n$ ping -c 3 www.google.com PING www.google.com (172.217.13.100) 56(84) bytes of data. 64 bytes from yul02s04-in-f4.1e100.net (172.217.13.100): icmp_seq=1 ttl=57 time=10.7 ms 64 bytes from yul02s04-in-f4.1e100.net (172.217.13.100): icmp_seq=2 ttl=57 time=9.60 ms 64 bytes from yul02s04-in-f4.1e100.net (172.217.13.100): icmp_seq=3 ttl=57 time=10.4 ms --- www.google.com ping statistics --- 3 packets transmitted, 3 received, 0% packet loss, time 2001ms rtt min/avg/max/mdev = 9.609/10.276/10.783/0.499 ms We are live!\nNote: On some distro, the ‘Shared with other computers’ is not available from the default settings. In this case fire up nm-connection-editor from a terminal instead of the network connections editor.\nSet a static MAC address Because we are connecting our Pi Zero as an Ethernet device through USB OTG, each time the connection is established the board is issued with a new random MAC address. This can be quickly annoying if we rely on the MAC address for, e.g. assigning a static IP to our board directly in our router configurations. This set up it totally optional.\nIn the boot partition, edit the file cmdline.txt and append at the end,\ng_ether.host_addr=aa:bb:cc:dd:ee:ff where aa:bb:cc:dd:ee:ff will be the static MAC address. We can use for instance the last mac address assigned to the board. To retrieve it, run ifconfig on the host machine and look for a connection along the lines enp0s29xxxxx.\nSet a static IP address We can also choose to assign a static IP address to our board so that we don’t have to look for it every now and then. To set a static IP address, edit the file /etc/dhcpcd.conf as follows,\ninterface usb0 static ip_address=10.42.0.42 static routers=10.42.0.1 Where 10.42.0.42 is your desired static IP address.\nReboot and have fun!\n","date":1590969600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590969600,"objectID":"cabbba69f5793d2ee22a280969a26a29","permalink":"https://artivis.github.io/post/2020/pi-zero/","publishdate":"2020-06-01T00:00:00Z","relpermalink":"/post/2020/pi-zero/","section":"post","summary":"In this post, we will see how to SSH a Raspberry Pi Zero over USB from a Ubuntu-based host. Moreover we will make sure the the Pi Zero has access to internet through the host so that we can install/update some software.","tags":["tutorial","Raspberry Pi","Raspberry Pi Zero","SSH","headless","Raspian"],"title":"SSH the Raspberry Pi Zero over USB","type":"post"},{"authors":null,"categories":null,"content":"In this post, we will discuss how to setup a Linux container - a.k.a LXC - for our ROS Noetic development. Developing in containers has several advantages such as:\nallowing us to use a different Linux distribution than the one we’ve installed on our host machine providing a repeatable course of actions messing around, installing a tons of dependencies without polluting our computer burning the container to the ground and starting fresh again easily There are of course many other upsides but those are the one we are really interested in for now. We will see first how to get started with LXC and install the latest ROS release Noetic. We will then configure our container so that it is able to share a workspace with our host machine. We will also enable the use of graphical applications from the container (e.g. Rviz, Gazebo).\nThe main prerequisites for this post are to be familiar with:\nthe command terminal in Linux ROS development LXC Note that I will be linking resources throughout the text, make sure to check them whenever you need further information.\nFinally, while we will be focusing on the latest ROS Noetic release, the setup presented here applies not only to other ROS distributions but likely to most projects, be them ROS-based or not.\nSetting up the LXC We will start by installing LXD, a lightweight container hypervisor which extends LXC functionality over the network. LXD uses LXC under the covers for some container management tasks and provides the ’lxc’ command line interface tool we will use throughout this post. For more information, you can refer to the LXC and LXD documentation on the Ubuntu website.\nAlright, let us install LXD as a snap to make sure we always run the most up to date stable version:\nsudo snap install lxd Before we can create our first container, we must initialize LXD,\nsudo lxd init This command will prompt you with a bunch of questions to fine tune LXD use. Unless you know what you are doing, you can safely hit the default answers.\nFinally, we will add our user to the ’lxd’ group so that we can run lxd commands without sudo,\nsudo gpasswd -a \u0026#34;${USER}\u0026#34; lxd You should log out and log in again for this to take effect.\nCreating the container To create a new container, we will use the following command,\nlxc launch {remote}:{image} {container-name} Since Noetic runs on Ubuntu 20.04, we will fetch a Ubuntu 20.04 image from the official Ubuntu remote,\nlxc launch ubuntu:20.04 ros-noetic We can check that the container was properly created and launched,\n$ lxc list +---------------+---------+-----------------------+-----------------------------------------------+-----------+-----------+ | NAME | STATE | IPV4 | IPV6 | TYPE | SNAPSHOTS | +---------------+---------+-----------------------+-----------------------------------------------+-----------+-----------+ | ros-noetic | RUNNING | 10.160.218.172 (eth0) | dd42:5ke1:fr68:2ca4:236:eff3:fe3r:7c21 (eth0) | CONTAINER | 0 | +---------------+---------+-----------------------+-----------------------------------------------+-----------+-----------+ With our container up and running, we can open a shell in it with a non-root user with the following command,\nlxc exec ros-noetic -- sudo --login --user ubuntu I know, this command is not very pretty nor easy to remember. But worry not, we will create an alias to ease future use.\nLXC aliases to the rescue LXC aliases, just like bash aliases, allow use to create a new CLI keywords to which we can associate an action. The command to create a new alias is,\nlxc alias add {alias} \u0026#39;{command}\u0026#39; As an example, let us create a shorter version of the lxc list command that also prints a more compact result:\nlxc alias add ls \u0026#39;list --format csv -c n\u0026#39; We can check that the alias is correctly created,\n$ lxc alias list +--------+----------------------------------------------------------------------------------+ | ALIAS | TARGET | +--------+----------------------------------------------------------------------------------+ | ls | list --format csv -c n | +--------+----------------------------------------------------------------------------------+ And we can now simply use it,\n$ lxc ls ros-noetic That’s pretty neat.\nBut our main goal with aliases was to simplify our shell login to the container, so let’s just do that. Borrowing from the excellent blog post by Simos Xenitellis about LXC aliases, we will create a new alias ‘ubuntu’ such as,\nlxc alias add ubuntu \u0026#39;exec @ARGS@ --mode interactive -- /bin/sh -xac $@ubuntu - exec /bin/login -p -f \u0026#39; This alias allows us now to simply connect to our container with,\nlxc ubuntu ros-noetic That’s much better isn’t it?\nInstall ROS Noetic ROS Noetic is the latest and final ROS 1 release. The ROS project hasn’t come to an end, on the contrary, it rather look forward and focus its efforts toward the second version, namely ROS 2. Nevertheless, ROS Noetic is an important release because it targets Ubuntu 20.04, has official Python 3 support and will be supported until May 2025 (more …","date":1590796800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590796800,"objectID":"6e9ac8c4106f150dee9ba7aed739cb49","permalink":"https://artivis.github.io/post/2020/lxc/","publishdate":"2020-05-30T00:00:00Z","relpermalink":"/post/2020/lxc/","section":"post","summary":"In this post, we will discuss how to setup a Linux container - a.k.a LXC - for our ROS Noetic development. Developing in containers has several advantages such as:\nallowing us to use a different Linux distribution than the one we’ve installed on our host machine providing a repeatable course of actions messing around, installing a tons of dependencies without polluting our computer burning the container to the ground and starting fresh again easily There are of course many other upsides but those are the one we are really interested in for now.","tags":["tutorial","LXC","LXD","ROS","Noetic","Ubuntu"],"title":"ROS Noetic development workflow in LXC","type":"post"},{"authors":null,"categories":null,"content":"Here we are, looking for online visibility. How does one set that up quickly when starting from scratch? Do you Remember those HTML courses? Yeah me neither. But fortunately for us it is now easier than ever!\nWe will discuss in this post how to create our own website with the Hugo framework from a template and how to deploy it to GitHub. The prerequisites are,\nGitHub markdown LXD (optional) You may find GitHub tutorials here and there. Pages of our website will be written in markdown. You can learn more about markdown from those tutorials, in English and in French. And if you only need a brief refresh, here is the syntax supported by our website. Finally, you can find a LXD tutorial here.\nNow, let us set up the necessary stuff to get started, shall we?\nPicking a website template To build our website, we will use the framework Hugo. It is very convenient for our use case because it comes with a ton of predefined website themes and it is very simple to use.\nFor the purpose of this tutorial we will use the very theme of this website, namely, Academic. This theme is rather clean, well organized, fairly simple to use and most importantly it is well documented! Furthermore, it can be found pre-bundled in a Hugo project so that it is pretty much clone and play. However, at the time of writing, this theme requires Hugo *Extended* version 0.67+. This distinction is important because, while it is conveniently packaged as a snap, the snap only offers the classic version, not the Extended. Therefore we have to fetch its debian package and install it manually.\nFirst, let us clone the ready-to-go Academic bundle on our machine:\ncd ~/ git clone https://github.com/sourcethemes/academic-kickstart.git my_website cd my_website git submodule update --init --recursive Prepping the tools To avoid polluting our system, we will set up a Linux container in which we will install Hugo Extended. The container is totally optional and you can do the installation directly on your machine. If you do not wish to use a container, skip directly to Hugo installation\nSetting up the LXC Let us start a fresh and pull a new Ubuntu 18.04 instance,\nlxc launch ubuntu:18.04 hugo We will now mount a disk device to share the website source code between our machine and the container:\nlxc config device add hugo workspace disk source=~/my_website path=/home/ubuntu/my_website lxc config set hugo raw.idmap \u0026#34;both $(id -u) $(id -g)\u0026#34; lxc restart hugo The default installation of LXD set up a bridged network so that containers live behind a NAT on the host. Therefore, we have to forward the port on which our website is served by the Hugo framework. To do so, issue the following command:\nlxc config device add hugo proxy1313 proxy connect=tcp:127.0.0.1:1313 listen=tcp:0.0.0.0:1313 The container is all set up. We can log to it with:\nlxc exec hugo -- su --login ubuntu Installing Hugo We will download the Hugo extended debian directly from it GitHub repository. To do so, enter in the terminal:\nwget https://github.com/gohugoio/hugo/releases/download/v0.70.0/hugo_extended_0.70.0_Linux-64bit.deb At the time of writing, the latest Hugo Extended release is version 0.70.0.\nWe can now install it with:\nsudo dpkg -i hugo_extended_*.deb First view of our website Let the show begin. We are now ready to spawn our website and browse it. In a terminal, enter:\ncd ~/my_website hugo server Voila!\nThe website it up and running! To visualize it, open your web browser at the address http://localhost:1313. That was easy right?\nMaking the website your own We have a great template up and running, it is now time to make it our own. The Academic theme comes with a ton of options and configurations allowing us to truly personalize it to our liking and use case. And since its online documentation is so great, I will let you discovers by yourself all the possibilities the theme offers. Head down to the Academic get started documentation and have fun!\nJust a quick advice, as you edit your website, let Hugo run. It is able to update the website live so that you see your changes take effect immediately in your web browser!\nDeploying the website to GitHub Once our website is ready to be made public, all there is to do is to push it to GitHub. Well, almost.\nIn your GitHub account, we will create a repository to host your website. To do so hit the tiny cross (+) in the top-right of GitHub and select new repository. For GitHub to be able to figure out that this particular repository is your personal website we need to give it a specific name in the form : \u0026lt;your-github-user-name\u0026gt;.github.io.\nWe will now prepare to push the website to this repository.\nFirst we will add the GitHub repository we just created as our remote,\ngit add remote origin https://github.com/\u0026lt;your-github-user-name\u0026gt;/\u0026lt;your-github-user-name\u0026gt;.github.io.git and change our branch name to avoid later mess,\ngit branch -m master builder Here comes the final step before pushing to GitHub. We must build our website, or rather let Hugo do it for …","date":1590710400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590710400,"objectID":"1935ac9469e8a1f3c15b0c1795f0e181","permalink":"https://artivis.github.io/post/2020/my-website/","publishdate":"2020-05-29T00:00:00Z","relpermalink":"/post/2020/my-website/","section":"post","summary":"Here we are, looking for online visibility. How does one set that up quickly when starting from scratch? Do you Remember those HTML courses? Yeah me neither. But fortunately for us it is now easier than ever!","tags":["tutorial","website","github","hugo","academic"],"title":"My website","type":"post"},{"authors":["J. Deray","J. Solà"],"categories":null,"content":"","date":1577836800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1577836800,"objectID":"7fa3cd8f940f34b8f7a680163f4018be","permalink":"https://artivis.github.io/publication/deray-joss-20/","publishdate":"2020-05-09T22:12:35.024894Z","relpermalink":"/publication/deray-joss-20/","section":"publication","summary":"","tags":null,"title":"Manif: A micro Lie theory library for state estimation in robotics applications","type":"publication"},{"authors":["J. Deray","B. Magyar","J. Solà","J. Andrade-Cetto"],"categories":null,"content":"","date":1572566400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1572566400,"objectID":"c85af36e1eed8e87dcbf3bc0775a3489","permalink":"https://artivis.github.io/publication/deray-iros-19/","publishdate":"2020-05-09T22:12:35.024619Z","relpermalink":"/publication/deray-iros-19/","section":"publication","summary":"This paper proposes the use of piecewise C^n smooth curve for mobile-base motion planning and control, coined Timed-Elastic Smooth Curve (TESC) planner. Based on a Timed-Elastic Band, the problem is defined so that the trajectory lies on a spline in SE(2) with non-vanishing n-th derivatives at every point. Formulated as a multi-objective nonlinear optimization problem, it allows imposing soft constraints such as collision-avoidance, velocity, acceleration and jerk limits, and more. The planning process is realtime-capable allowing the robot to navigate in dynamic complex scenarios. The proposed method is compared against the state-of-the-art in various scenarios. Results show that trajectories generated by the TESC planner have smaller average acceleration and are more efficient in terms of total curvature and pseudo-kinetic energy while being produced with more consistency than state-of-the-art planners do.","tags":null,"title":"Timed-elastic smooth curve optimization for mobile-base motion planning","type":"publication"},{"authors":["B. Magyar","N. Tsiogkas","J. Deray","S. Pfeiffer","D. Lane"],"categories":null,"content":"","date":1569888e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1569888e3,"objectID":"fb969b8e309ab70a3bcc5186994d3c71","permalink":"https://artivis.github.io/publication/magyar-ral-19/","publishdate":"2020-05-09T22:12:35.024339Z","relpermalink":"/publication/magyar-ral-19/","section":"publication","summary":"Motion planning is one of the main problems studied in the field of robotics. However, it is still challenging for the state-of-the-art methods to handle multiple conditions that allow better paths to be found. For example, considering joint limits, path smoothness and a mixture of Cartesian and joint-space constraints at the same time pose a significant challenge for many of them. This letter proposes to use timed-elastic bands for representing the manipulation motion planning problem, allowing to apply continuously optimized constraints to the problem during the search for a solution. Due to the nature of our method, it is highly extensible with new constraints or optimization objectives. The proposed approach is compared against state-of-the-art methods in various manipulation scenarios. The results show that it is more consistent and less variant, while performing in a comparable manner to that of the state of the art. This behavior allows the proposed method to set a lower-bound performance guarantee for other methods to build upon.","tags":null,"title":"Timed-Elastic Bands for Manipulation Motion Planning","type":"publication"},{"authors":["J. Deray","J. Solà","J. Andrade-Cetto"],"categories":null,"content":"","date":1567296e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1567296e3,"objectID":"d45f264f27e2c46ce1db468c8ab920ef","permalink":"https://artivis.github.io/publication/deray-ecmr-19/","publishdate":"2020-05-09T22:12:35.024059Z","relpermalink":"/publication/deray-ecmr-19/","section":"publication","summary":"This paper describes a self-calibration procedure that jointly estimates the extrinsic parameters of an exteroceptive sensor able to observe ego-motion, and the intrinsic parameters of an odometry motion model, consisting of wheel radii and wheel separation. We use iterative nonlinear on-manifold optimization with a graphical representation of the state, and resort to an adaptation of the pre-integration theory, initially developed for the IMU motion sensor, to be applied to the differential drive motion model. For this, we describe the construction of a pre-integrated factor for the differential drive motion model, which includes the motion increment, its covariance, and a first-order approximation of its dependence with the calibration parameters. As the calibration parameters change at each solver iteration, this allows a posteriori factor correction without the need of re-integrating the motion data. We validate our proposal in simulations and on a real robot and show the convergence of the calibration towards the true values of the parameters. It is then tested online in simulation and is shown to accommodate to variations in the calibration parameters when the vehicle is subject to physical changes such as loading and unloading a freight.","tags":null,"title":"Joint on-manifold self-calibration of odometry model and sensor extrinsics using pre-integration","type":"publication"},{"authors":["Joan Solà","Jeremie Deray","Dinesh Atchuthan"],"categories":null,"content":"","date":1514764800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1514764800,"objectID":"000f76c98004a939852ee292393c6e91","permalink":"https://artivis.github.io/publication/sola-18-lie/","publishdate":"2020-05-09T22:12:35.023827Z","relpermalink":"/publication/sola-18-lie/","section":"publication","summary":"A Lie group is an old mathematical abstract object dating back to the XIX century, when mathematician Sophus Lie laid the foundations of the theory of continuous transformation groups. As it often happens, its usage has spread over diverse areas of science and technology many years later. In robotics, we are recently experiencing an important trend in its usage, at least in the fields of estimation, and particularly in motion estimation for navigation. Yet for a vast majority of roboticians, Lie groups are highly abstract constructions and therefore difficult to understand and to use. This may be due to the fact that most of the literature on Lie theory is written by and for mathematicians and physicists, who might be more used than us to the deep abstractions this theory deals with. In estimation for robotics it is often not necessary to exploit the full capacity of the theory, and therefore an effort of selection of materials is required. In this paper, we will walk through the most basic principles of the Lie theory, with the aim of conveying clear and useful ideas, and leave a significant corpus of the Lie theory behind. Even with this mutilation, the material included here has proven to be extremely useful in modern estimation algorithms for robotics, especially in the fields of SLAM, visual odometry, and the like. Alongside this micro Lie theory, we provide a chapter with a few application examples, and a vast reference of formulas for the major Lie groups used in robotics, including most jacobian matrices and the way to easily manipulate them. We also present a new C++ template-only library implementing all the functionality described here.","tags":null,"title":"A micro Lie theory for state estimation in robotics","type":"publication"},{"authors":["J. Deray","J. Solà","J. Andrade-Cetto"],"categories":null,"content":"","date":1498867200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1498867200,"objectID":"6db2d53f82fb7607daaa1272edfece84","permalink":"https://artivis.github.io/publication/deray-ral-17/","publishdate":"2020-05-09T22:12:35.023482Z","relpermalink":"/publication/deray-ral-17/","section":"publication","summary":"We address in this letter the problem of loop closure detection for laser-based simultaneous localization and mapping (SLAM) of very large areas. Consistent with the state of the art, the map is encoded as a graph of poses, and to cope with very large mapping capabilities, loop closures are asserted by comparing the features extracted from a query laser scan against a previously acquired corpus of scan features using a bag-of-words (BoW) scheme. Two contributions are here presented. First, to benefit from the graph topology, feature frequency scores in the BoW are computed not only for each individual scan but also from neighboring scans in the SLAM graph. This has the effect of enforcing neighbor relational information during document matching. Second, a weak geometric check that takes into account feature ordering and occlusions is introduced that substantially improves loop closure detection performance. The two contributions are evaluated both separately and jointly on four common SLAM datasets and are shown to improve the state-of-the-art performance both in terms of precision and recall in most of the cases. Moreover, our current implementation is designed to work at nearly frame rate, allowing loop closure query resolution at nearly 22 Hz for the best case scenario and 2 Hz for the worst case scenario.","tags":null,"title":"Word ordering and document adjacency for large loop closure detection in 2D laser maps","type":"publication"},{"authors":["D. Gurung","C. Jiang","J. Deray","D. Sidibé"],"categories":null,"content":"","date":1370044800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1370044800,"objectID":"a126fbe7e6fa32b887faf2964b8e5fae","permalink":"https://artivis.github.io/publication/gurung-hal-00903898/","publishdate":"2020-05-09T22:12:35.023088Z","relpermalink":"/publication/gurung-hal-00903898/","section":"publication","summary":"In this project we develop a system that uses low cost web cameras to recognise gestures and track 2D orientations of the hand. This report is organized as such. First in section 2 we introduce various methods we undertook for hand detection. This is the most important step in hand gesture recognition. Results of various skin detection algorithms are discussed in length. This is followed by region extraction step (section 3). In this section approaches like contours and convex hull to extract region of interest which is hand are discussed. In section 4 a method is describe to recognize the open hand gesture. Two additional gestures of palm and fist are implemented using Haar-like features. These are discussed in section 5. In section 6 Kalman filter is introduced which tracks the centroid of hand region. The report is concluded by discussing about various issues related with the embraced approach (section 9) and future recommendations to improve the system is pointed out (section 10).","tags":null,"title":"Hand Gestures Recognition and Tracking","type":"publication"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"8576ec274c98b3831668a172fa632d80","permalink":"https://artivis.github.io/about/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/about/","section":"","summary":"","tags":null,"title":"","type":"widget_page"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"6d99026b9e19e4fa43d5aadf147c7176","permalink":"https://artivis.github.io/contact/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/contact/","section":"","summary":"","tags":null,"title":"","type":"widget_page"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"9a6cb9348361050ffbcc0117246adb56","permalink":"https://artivis.github.io/tag/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/tag/","section":"","summary":"","tags":null,"title":"","type":"widget_page"}]